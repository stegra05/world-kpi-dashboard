"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/dataParser.ts":
/*!*********************************!*\
  !*** ./src/utils/dataParser.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAggregatedDataByCountry: function() { return /* binding */ getAggregatedDataByCountry; },\n/* harmony export */   getCountryData: function() { return /* binding */ getCountryData; },\n/* harmony export */   getFilteredData: function() { return /* binding */ getFilteredData; },\n/* harmony export */   getMinMaxValues: function() { return /* binding */ getMinMaxValues; },\n/* harmony export */   getUniqueBatteryAliases: function() { return /* binding */ getUniqueBatteryAliases; },\n/* harmony export */   getUniqueClimateTypes: function() { return /* binding */ getUniqueClimateTypes; },\n/* harmony export */   getUniqueContinents: function() { return /* binding */ getUniqueContinents; },\n/* harmony export */   getUniqueModelSeries: function() { return /* binding */ getUniqueModelSeries; },\n/* harmony export */   getUniqueVariables: function() { return /* binding */ getUniqueVariables; },\n/* harmony export */   parseData: function() { return /* binding */ parseData; }\n/* harmony export */ });\nfunction parseData(csvText) {\n    const lines = csvText.split(\"\\n\");\n    // Debug the header line\n    console.log(\"Header line:\", lines[0]);\n    const header = lines[0].split(\";\");\n    console.log(\"Header fields:\", header);\n    const data = [];\n    // Skip header line and parse each data line\n    for(let i = 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue; // Skip empty lines\n        const values = line.split(\";\");\n        if (values.length !== header.length) {\n            console.warn(\"Skipping malformed line \".concat(i, \": Expected \").concat(header.length, \" fields, got \").concat(values.length));\n            continue; // Skip malformed lines\n        }\n        // Debug log first few parsings\n        if (i < 5) {\n            console.log(\"Parsing line \".concat(i, \":\"), values);\n        }\n        try {\n            // Ensure iso_a3 is uppercase for consistent lookup\n            const iso_a3 = values[4] ? values[4].toUpperCase().trim() : \"\";\n            data.push({\n                battAlias: values[0],\n                country: values[1],\n                continent: values[2],\n                climate: values[3],\n                iso_a3: iso_a3,\n                model_series: values[5],\n                variable: values[6],\n                value: parseInt(values[7], 10) || 0,\n                description: values[8],\n                count: parseInt(values[9], 10) || 0 // Default to 0 if parsing fails\n            });\n        } catch (err) {\n            console.error(\"Error parsing line \".concat(i, \":\"), err);\n        }\n    }\n    // Debug summary\n    console.log(\"Parsed data summary:\");\n    console.log(\"Total data points: \".concat(data.length));\n    console.log(\"Countries: \".concat(new Set(data.map((item)=>item.country)).size));\n    console.log(\"ISO codes: \".concat(new Set(data.map((item)=>item.iso_a3)).size));\n    // Log all unique ISO codes for debugging\n    const isoCodes = [\n        ...new Set(data.map((item)=>item.iso_a3))\n    ].filter(Boolean).sort();\n    console.log(\"All ISO codes:\", isoCodes);\n    console.log(\"Variables: \".concat(new Set(data.map((item)=>item.variable)).size));\n    return data;\n}\nfunction getCountryData(data, countryCode) {\n    return data.filter((item)=>item.iso_a3 === countryCode);\n}\nfunction getUniqueVariables(data) {\n    return [\n        ...new Set(data.map((item)=>item.variable))\n    ];\n}\nfunction getUniqueBatteryAliases(data) {\n    return [\n        ...new Set(data.map((item)=>item.battAlias))\n    ];\n}\nfunction getUniqueContinents(data) {\n    return [\n        ...new Set(data.map((item)=>item.continent).filter((continent)=>continent))\n    ];\n}\nfunction getUniqueClimateTypes(data) {\n    return [\n        ...new Set(data.map((item)=>item.climate).filter((climate)=>climate))\n    ];\n}\nfunction getUniqueModelSeries(data) {\n    return [\n        ...new Set(data.map((item)=>item.model_series).filter((series)=>series))\n    ];\n}\nfunction getFilteredData(data, filters) {\n    return data.filter((item)=>{\n        // Always filter by variable\n        if (item.variable !== filters.variable) return false;\n        // Apply optional filters\n        if (filters.battAlias && item.battAlias !== filters.battAlias) return false;\n        if (filters.continent && item.continent !== filters.continent) return false;\n        if (filters.climate && item.climate !== filters.climate) return false;\n        if (filters.model_series && item.model_series !== filters.model_series) return false;\n        return true;\n    });\n}\nfunction getAggregatedDataByCountry(data, variable, filters) {\n    const result = {};\n    // Filter data for the selected variable and other filters\n    let filteredData = data.filter((item)=>item.variable === variable);\n    // Apply optional filters\n    if (filters) {\n        if (filters.battAlias) {\n            filteredData = filteredData.filter((item)=>item.battAlias === filters.battAlias);\n        }\n        if (filters.continent) {\n            filteredData = filteredData.filter((item)=>item.continent === filters.continent);\n        }\n        if (filters.climate) {\n            filteredData = filteredData.filter((item)=>item.climate === filters.climate);\n        }\n        if (filters.model_series) {\n            filteredData = filteredData.filter((item)=>item.model_series === filters.model_series);\n        }\n    }\n    // Debug the filtered data\n    console.log(\"After filtering for \".concat(variable, \", \").concat(filteredData.length, \" data points remain\"));\n    if (filteredData.length > 0) {\n        console.log(\"Sample filtered data:\", filteredData.slice(0, 3));\n    }\n    // Aggregate by country\n    filteredData.forEach((item)=>{\n        // Make sure iso_a3 is uppercase for consistent lookup\n        const countryCode = item.iso_a3 ? item.iso_a3.toUpperCase() : \"\";\n        if (countryCode) {\n            if (result[countryCode]) {\n                result[countryCode] += item.value;\n            } else {\n                result[countryCode] = item.value;\n            }\n        }\n    });\n    // Debug the result\n    console.log(\"Aggregated data for \".concat(Object.keys(result).length, \" countries\"));\n    return result;\n}\nfunction getMinMaxValues(data) {\n    const values = Object.values(data);\n    return {\n        min: Math.min(...values),\n        max: Math.max(...values)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVF6QixZQUFZO1FBQ3ZGO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUJqQixRQUFRQyxHQUFHLENBQUMsdUJBQW9DNEMsT0FBYjNCLFVBQVMsTUFBd0IsT0FBcEIyQixhQUFheEMsTUFBTSxFQUFDO0lBQ3BFLElBQUl3QyxhQUFheEMsTUFBTSxHQUFHLEdBQUc7UUFDM0JMLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUI0QyxhQUFhQyxLQUFLLENBQUMsR0FBRztJQUM3RDtJQUVBLHVCQUF1QjtJQUN2QkQsYUFBYUUsT0FBTyxDQUFDcEIsQ0FBQUE7UUFDbkIsc0RBQXNEO1FBQ3RELE1BQU1PLGNBQWNQLEtBQUtqQixNQUFNLEdBQUdpQixLQUFLakIsTUFBTSxDQUFDQyxXQUFXLEtBQUs7UUFFOUQsSUFBSXVCLGFBQWE7WUFDZixJQUFJVSxNQUFNLENBQUNWLFlBQVksRUFBRTtnQkFDdkJVLE1BQU0sQ0FBQ1YsWUFBWSxJQUFJUCxLQUFLUixLQUFLO1lBQ25DLE9BQU87Z0JBQ0x5QixNQUFNLENBQUNWLFlBQVksR0FBR1AsS0FBS1IsS0FBSztZQUNsQztRQUNGO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkJuQixRQUFRQyxHQUFHLENBQUMsdUJBQWtELE9BQTNCK0MsT0FBT0MsSUFBSSxDQUFDTCxRQUFRdkMsTUFBTSxFQUFDO0lBRTlELE9BQU91QztBQUNUO0FBRU8sU0FBU00sZ0JBQWdCL0MsSUFBNEI7SUFDMUQsTUFBTUssU0FBU3dDLE9BQU94QyxNQUFNLENBQUNMO0lBQzdCLE9BQU87UUFDTGdELEtBQUtDLEtBQUtELEdBQUcsSUFBSTNDO1FBQ2pCNkMsS0FBS0QsS0FBS0MsR0FBRyxJQUFJN0M7SUFDbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvZGF0YVBhcnNlci50cz8xODg5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgS1BJRGF0YSB7XG4gIGJhdHRBbGlhczogc3RyaW5nO1xuICBjb3VudHJ5OiBzdHJpbmc7XG4gIGNvbnRpbmVudDogc3RyaW5nO1xuICBjbGltYXRlOiBzdHJpbmc7XG4gIGlzb19hMzogc3RyaW5nO1xuICBtb2RlbF9zZXJpZXM6IHN0cmluZztcbiAgdmFyaWFibGU6IHN0cmluZztcbiAgdmFsdWU6IG51bWJlcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0YShjc3ZUZXh0OiBzdHJpbmcpOiBLUElEYXRhW10ge1xuICBjb25zdCBsaW5lcyA9IGNzdlRleHQuc3BsaXQoJ1xcbicpO1xuICBcbiAgLy8gRGVidWcgdGhlIGhlYWRlciBsaW5lXG4gIGNvbnNvbGUubG9nKCdIZWFkZXIgbGluZTonLCBsaW5lc1swXSk7XG4gIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdLnNwbGl0KCc7Jyk7XG4gIGNvbnNvbGUubG9nKCdIZWFkZXIgZmllbGRzOicsIGhlYWRlcik7XG4gIFxuICBjb25zdCBkYXRhOiBLUElEYXRhW10gPSBbXTtcbiAgXG4gIC8vIFNraXAgaGVhZGVyIGxpbmUgYW5kIHBhcnNlIGVhY2ggZGF0YSBsaW5lXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuICAgIGlmICghbGluZSkgY29udGludWU7IC8vIFNraXAgZW1wdHkgbGluZXNcbiAgICBcbiAgICBjb25zdCB2YWx1ZXMgPSBsaW5lLnNwbGl0KCc7Jyk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgbWFsZm9ybWVkIGxpbmUgJHtpfTogRXhwZWN0ZWQgJHtoZWFkZXIubGVuZ3RofSBmaWVsZHMsIGdvdCAke3ZhbHVlcy5sZW5ndGh9YCk7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCBtYWxmb3JtZWQgbGluZXNcbiAgICB9XG4gICAgXG4gICAgLy8gRGVidWcgbG9nIGZpcnN0IGZldyBwYXJzaW5nc1xuICAgIGlmIChpIDwgNSkge1xuICAgICAgY29uc29sZS5sb2coYFBhcnNpbmcgbGluZSAke2l9OmAsIHZhbHVlcyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBFbnN1cmUgaXNvX2EzIGlzIHVwcGVyY2FzZSBmb3IgY29uc2lzdGVudCBsb29rdXBcbiAgICAgIGNvbnN0IGlzb19hMyA9IHZhbHVlc1s0XSA/IHZhbHVlc1s0XS50b1VwcGVyQ2FzZSgpLnRyaW0oKSA6ICcnO1xuICAgICAgXG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBiYXR0QWxpYXM6IHZhbHVlc1swXSxcbiAgICAgICAgY291bnRyeTogdmFsdWVzWzFdLFxuICAgICAgICBjb250aW5lbnQ6IHZhbHVlc1syXSxcbiAgICAgICAgY2xpbWF0ZTogdmFsdWVzWzNdLFxuICAgICAgICBpc29fYTM6IGlzb19hMyxcbiAgICAgICAgbW9kZWxfc2VyaWVzOiB2YWx1ZXNbNV0sXG4gICAgICAgIHZhcmlhYmxlOiB2YWx1ZXNbNl0sXG4gICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZXNbN10sIDEwKSB8fCAwLCAvLyBEZWZhdWx0IHRvIDAgaWYgcGFyc2luZyBmYWlsc1xuICAgICAgICBkZXNjcmlwdGlvbjogdmFsdWVzWzhdLFxuICAgICAgICBjb3VudDogcGFyc2VJbnQodmFsdWVzWzldLCAxMCkgfHwgMCAgLy8gRGVmYXVsdCB0byAwIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBsaW5lICR7aX06YCwgZXJyKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIERlYnVnIHN1bW1hcnlcbiAgY29uc29sZS5sb2coJ1BhcnNlZCBkYXRhIHN1bW1hcnk6Jyk7XG4gIGNvbnNvbGUubG9nKGBUb3RhbCBkYXRhIHBvaW50czogJHtkYXRhLmxlbmd0aH1gKTtcbiAgY29uc29sZS5sb2coYENvdW50cmllczogJHtuZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS5jb3VudHJ5KSkuc2l6ZX1gKTtcbiAgY29uc29sZS5sb2coYElTTyBjb2RlczogJHtuZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS5pc29fYTMpKS5zaXplfWApO1xuICBcbiAgLy8gTG9nIGFsbCB1bmlxdWUgSVNPIGNvZGVzIGZvciBkZWJ1Z2dpbmdcbiAgY29uc3QgaXNvQ29kZXMgPSBbLi4ubmV3IFNldChkYXRhLm1hcChpdGVtID0+IGl0ZW0uaXNvX2EzKSldLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gIGNvbnNvbGUubG9nKCdBbGwgSVNPIGNvZGVzOicsIGlzb0NvZGVzKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBWYXJpYWJsZXM6ICR7bmV3IFNldChkYXRhLm1hcChpdGVtID0+IGl0ZW0udmFyaWFibGUpKS5zaXplfWApO1xuICBcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3VudHJ5RGF0YShkYXRhOiBLUElEYXRhW10sIGNvdW50cnlDb2RlOiBzdHJpbmcpOiBLUElEYXRhW10ge1xuICByZXR1cm4gZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmlzb19hMyA9PT0gY291bnRyeUNvZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlVmFyaWFibGVzKGRhdGE6IEtQSURhdGFbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS52YXJpYWJsZSkpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZUJhdHRlcnlBbGlhc2VzKGRhdGE6IEtQSURhdGFbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS5iYXR0QWxpYXMpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlxdWVDb250aW5lbnRzKGRhdGE6IEtQSURhdGFbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS5jb250aW5lbnQpLmZpbHRlcihjb250aW5lbnQgPT4gY29udGluZW50KSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlQ2xpbWF0ZVR5cGVzKGRhdGE6IEtQSURhdGFbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGRhdGEubWFwKGl0ZW0gPT4gaXRlbS5jbGltYXRlKS5maWx0ZXIoY2xpbWF0ZSA9PiBjbGltYXRlKSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlTW9kZWxTZXJpZXMoZGF0YTogS1BJRGF0YVtdKTogc3RyaW5nW10ge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoZGF0YS5tYXAoaXRlbSA9PiBpdGVtLm1vZGVsX3NlcmllcykuZmlsdGVyKHNlcmllcyA9PiBzZXJpZXMpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJlZERhdGEoXG4gIGRhdGE6IEtQSURhdGFbXSwgXG4gIGZpbHRlcnM6IHtcbiAgICBiYXR0QWxpYXM/OiBzdHJpbmcsXG4gICAgY29udGluZW50Pzogc3RyaW5nLFxuICAgIGNsaW1hdGU/OiBzdHJpbmcsXG4gICAgbW9kZWxfc2VyaWVzPzogc3RyaW5nLFxuICAgIHZhcmlhYmxlOiBzdHJpbmdcbiAgfVxuKTogS1BJRGF0YVtdIHtcbiAgcmV0dXJuIGRhdGEuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIC8vIEFsd2F5cyBmaWx0ZXIgYnkgdmFyaWFibGVcbiAgICBpZiAoaXRlbS52YXJpYWJsZSAhPT0gZmlsdGVycy52YXJpYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIEFwcGx5IG9wdGlvbmFsIGZpbHRlcnNcbiAgICBpZiAoZmlsdGVycy5iYXR0QWxpYXMgJiYgaXRlbS5iYXR0QWxpYXMgIT09IGZpbHRlcnMuYmF0dEFsaWFzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGZpbHRlcnMuY29udGluZW50ICYmIGl0ZW0uY29udGluZW50ICE9PSBmaWx0ZXJzLmNvbnRpbmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChmaWx0ZXJzLmNsaW1hdGUgJiYgaXRlbS5jbGltYXRlICE9PSBmaWx0ZXJzLmNsaW1hdGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZmlsdGVycy5tb2RlbF9zZXJpZXMgJiYgaXRlbS5tb2RlbF9zZXJpZXMgIT09IGZpbHRlcnMubW9kZWxfc2VyaWVzKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWdncmVnYXRlZERhdGFCeUNvdW50cnkoZGF0YTogS1BJRGF0YVtdLCB2YXJpYWJsZTogc3RyaW5nLCBmaWx0ZXJzPzoge1xuICBiYXR0QWxpYXM/OiBzdHJpbmcsXG4gIGNvbnRpbmVudD86IHN0cmluZyxcbiAgY2xpbWF0ZT86IHN0cmluZyxcbiAgbW9kZWxfc2VyaWVzPzogc3RyaW5nXG59KTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBcbiAgLy8gRmlsdGVyIGRhdGEgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYWJsZSBhbmQgb3RoZXIgZmlsdGVyc1xuICBsZXQgZmlsdGVyZWREYXRhID0gZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLnZhcmlhYmxlID09PSB2YXJpYWJsZSk7XG4gIFxuICAvLyBBcHBseSBvcHRpb25hbCBmaWx0ZXJzXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgaWYgKGZpbHRlcnMuYmF0dEFsaWFzKSB7XG4gICAgICBmaWx0ZXJlZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5iYXR0QWxpYXMgPT09IGZpbHRlcnMuYmF0dEFsaWFzKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMuY29udGluZW50KSB7XG4gICAgICBmaWx0ZXJlZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jb250aW5lbnQgPT09IGZpbHRlcnMuY29udGluZW50KTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMuY2xpbWF0ZSkge1xuICAgICAgZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihpdGVtID0+IGl0ZW0uY2xpbWF0ZSA9PT0gZmlsdGVycy5jbGltYXRlKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubW9kZWxfc2VyaWVzKSB7XG4gICAgICBmaWx0ZXJlZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5tb2RlbF9zZXJpZXMgPT09IGZpbHRlcnMubW9kZWxfc2VyaWVzKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIERlYnVnIHRoZSBmaWx0ZXJlZCBkYXRhXG4gIGNvbnNvbGUubG9nKGBBZnRlciBmaWx0ZXJpbmcgZm9yICR7dmFyaWFibGV9LCAke2ZpbHRlcmVkRGF0YS5sZW5ndGh9IGRhdGEgcG9pbnRzIHJlbWFpbmApO1xuICBpZiAoZmlsdGVyZWREYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zb2xlLmxvZygnU2FtcGxlIGZpbHRlcmVkIGRhdGE6JywgZmlsdGVyZWREYXRhLnNsaWNlKDAsIDMpKTtcbiAgfVxuICBcbiAgLy8gQWdncmVnYXRlIGJ5IGNvdW50cnlcbiAgZmlsdGVyZWREYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgLy8gTWFrZSBzdXJlIGlzb19hMyBpcyB1cHBlcmNhc2UgZm9yIGNvbnNpc3RlbnQgbG9va3VwXG4gICAgY29uc3QgY291bnRyeUNvZGUgPSBpdGVtLmlzb19hMyA/IGl0ZW0uaXNvX2EzLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICBcbiAgICBpZiAoY291bnRyeUNvZGUpIHtcbiAgICAgIGlmIChyZXN1bHRbY291bnRyeUNvZGVdKSB7XG4gICAgICAgIHJlc3VsdFtjb3VudHJ5Q29kZV0gKz0gaXRlbS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtjb3VudHJ5Q29kZV0gPSBpdGVtLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBEZWJ1ZyB0aGUgcmVzdWx0XG4gIGNvbnNvbGUubG9nKGBBZ2dyZWdhdGVkIGRhdGEgZm9yICR7T2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGh9IGNvdW50cmllc2ApO1xuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbk1heFZhbHVlcyhkYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTogeyBtaW46IG51bWJlciwgbWF4OiBudW1iZXIgfSB7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG4gIHJldHVybiB7XG4gICAgbWluOiBNYXRoLm1pbiguLi52YWx1ZXMpLFxuICAgIG1heDogTWF0aC5tYXgoLi4udmFsdWVzKVxuICB9O1xufSAiXSwibmFtZXMiOlsicGFyc2VEYXRhIiwiY3N2VGV4dCIsImxpbmVzIiwic3BsaXQiLCJjb25zb2xlIiwibG9nIiwiaGVhZGVyIiwiZGF0YSIsImkiLCJsZW5ndGgiLCJsaW5lIiwidHJpbSIsInZhbHVlcyIsIndhcm4iLCJpc29fYTMiLCJ0b1VwcGVyQ2FzZSIsInB1c2giLCJiYXR0QWxpYXMiLCJjb3VudHJ5IiwiY29udGluZW50IiwiY2xpbWF0ZSIsIm1vZGVsX3NlcmllcyIsInZhcmlhYmxlIiwidmFsdWUiLCJwYXJzZUludCIsImRlc2NyaXB0aW9uIiwiY291bnQiLCJlcnIiLCJlcnJvciIsIlNldCIsIm1hcCIsIml0ZW0iLCJzaXplIiwiaXNvQ29kZXMiLCJmaWx0ZXIiLCJCb29sZWFuIiwic29ydCIsImdldENvdW50cnlEYXRhIiwiY291bnRyeUNvZGUiLCJnZXRVbmlxdWVWYXJpYWJsZXMiLCJnZXRVbmlxdWVCYXR0ZXJ5QWxpYXNlcyIsImdldFVuaXF1ZUNvbnRpbmVudHMiLCJnZXRVbmlxdWVDbGltYXRlVHlwZXMiLCJnZXRVbmlxdWVNb2RlbFNlcmllcyIsInNlcmllcyIsImdldEZpbHRlcmVkRGF0YSIsImZpbHRlcnMiLCJnZXRBZ2dyZWdhdGVkRGF0YUJ5Q291bnRyeSIsInJlc3VsdCIsImZpbHRlcmVkRGF0YSIsInNsaWNlIiwiZm9yRWFjaCIsIk9iamVjdCIsImtleXMiLCJnZXRNaW5NYXhWYWx1ZXMiLCJtaW4iLCJNYXRoIiwibWF4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/dataParser.ts\n"));

/***/ })

});