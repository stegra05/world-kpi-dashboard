"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-maps";
exports.ids = ["vendor-chunks/react-simple-maps"];
exports.modules = {

/***/ "./node_modules/react-simple-maps/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-simple-maps/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"react\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"prop-types\");\nvar d3Geo = __webpack_require__(/*! d3-geo */ \"d3-geo\");\nvar topojsonClient = __webpack_require__(/*! topojson-client */ \"topojson-client\");\nvar d3Zoom = __webpack_require__(/*! d3-zoom */ \"d3-zoom\");\nvar d3Selection = __webpack_require__(/*! d3-selection */ \"d3-selection\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\nvar PropTypes__default = /*#__PURE__*/ _interopDefaultLegacy(PropTypes);\nvar d3Geo__namespace = /*#__PURE__*/ _interopNamespace(d3Geo);\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar _excluded$a = [\n    \"width\",\n    \"height\",\n    \"projection\",\n    \"projectionConfig\"\n];\nvar geoPath = d3Geo__namespace.geoPath, projections = _objectWithoutProperties(d3Geo__namespace, [\n    \"geoPath\"\n]);\nvar MapContext = React.createContext();\nvar makeProjection = function makeProjection(_ref) {\n    var _ref$projectionConfig = _ref.projectionConfig, projectionConfig = _ref$projectionConfig === void 0 ? {} : _ref$projectionConfig, _ref$projection = _ref.projection, projection = _ref$projection === void 0 ? \"geoEqualEarth\" : _ref$projection, _ref$width = _ref.width, width = _ref$width === void 0 ? 800 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 600 : _ref$height;\n    var isFunc = typeof projection === \"function\";\n    if (isFunc) return projection;\n    var proj = projections[projection]().translate([\n        width / 2,\n        height / 2\n    ]);\n    var supported = [\n        proj.center ? \"center\" : null,\n        proj.rotate ? \"rotate\" : null,\n        proj.scale ? \"scale\" : null,\n        proj.parallels ? \"parallels\" : null\n    ];\n    supported.forEach(function(d) {\n        if (!d) return;\n        proj = proj[d](projectionConfig[d] || proj[d]());\n    });\n    return proj;\n};\nvar MapProvider = function MapProvider(_ref2) {\n    var width = _ref2.width, height = _ref2.height, projection = _ref2.projection, projectionConfig = _ref2.projectionConfig, restProps = _objectWithoutProperties(_ref2, _excluded$a);\n    var _ref3 = projectionConfig.center || [], _ref4 = _slicedToArray(_ref3, 2), cx = _ref4[0], cy = _ref4[1];\n    var _ref5 = projectionConfig.rotate || [], _ref6 = _slicedToArray(_ref5, 3), rx = _ref6[0], ry = _ref6[1], rz = _ref6[2];\n    var _ref7 = projectionConfig.parallels || [], _ref8 = _slicedToArray(_ref7, 2), p1 = _ref8[0], p2 = _ref8[1];\n    var s = projectionConfig.scale || null;\n    var projMemo = React.useMemo(function() {\n        return makeProjection({\n            projectionConfig: {\n                center: cx || cx === 0 || cy || cy === 0 ? [\n                    cx,\n                    cy\n                ] : null,\n                rotate: rx || rx === 0 || ry || ry === 0 ? [\n                    rx,\n                    ry,\n                    rz\n                ] : null,\n                parallels: p1 || p1 === 0 || p2 || p2 === 0 ? [\n                    p1,\n                    p2\n                ] : null,\n                scale: s\n            },\n            projection: projection,\n            width: width,\n            height: height\n        });\n    }, [\n        width,\n        height,\n        projection,\n        cx,\n        cy,\n        rx,\n        ry,\n        rz,\n        p1,\n        p2,\n        s\n    ]);\n    var proj = React.useCallback(projMemo, [\n        projMemo\n    ]);\n    var value = React.useMemo(function() {\n        return {\n            width: width,\n            height: height,\n            projection: proj,\n            path: geoPath().projection(proj)\n        };\n    }, [\n        width,\n        height,\n        proj\n    ]);\n    return /*#__PURE__*/ React__default[\"default\"].createElement(MapContext.Provider, _extends({\n        value: value\n    }, restProps));\n};\nMapProvider.propTypes = {\n    width: PropTypes__default[\"default\"].number,\n    height: PropTypes__default[\"default\"].number,\n    projection: PropTypes__default[\"default\"].oneOfType([\n        PropTypes__default[\"default\"].string,\n        PropTypes__default[\"default\"].func\n    ]),\n    projectionConfig: PropTypes__default[\"default\"].object\n};\nvar useMapContext = function useMapContext() {\n    return React.useContext(MapContext);\n};\nvar _excluded$9 = [\n    \"width\",\n    \"height\",\n    \"projection\",\n    \"projectionConfig\",\n    \"className\"\n];\nvar ComposableMap = React.forwardRef(function(_ref, ref) {\n    var _ref$width = _ref.width, width = _ref$width === void 0 ? 800 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 600 : _ref$height, _ref$projection = _ref.projection, projection = _ref$projection === void 0 ? \"geoEqualEarth\" : _ref$projection, _ref$projectionConfig = _ref.projectionConfig, projectionConfig = _ref$projectionConfig === void 0 ? {} : _ref$projectionConfig, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$9);\n    return /*#__PURE__*/ React__default[\"default\"].createElement(MapProvider, {\n        width: width,\n        height: height,\n        projection: projection,\n        projectionConfig: projectionConfig\n    }, /*#__PURE__*/ React__default[\"default\"].createElement(\"svg\", _extends({\n        ref: ref,\n        viewBox: \"0 0 \".concat(width, \" \").concat(height),\n        className: \"rsm-svg \".concat(className)\n    }, restProps)));\n});\nComposableMap.displayName = \"ComposableMap\";\nComposableMap.propTypes = {\n    width: PropTypes__default[\"default\"].number,\n    height: PropTypes__default[\"default\"].number,\n    projection: PropTypes__default[\"default\"].oneOfType([\n        PropTypes__default[\"default\"].string,\n        PropTypes__default[\"default\"].func\n    ]),\n    projectionConfig: PropTypes__default[\"default\"].object,\n    className: PropTypes__default[\"default\"].string\n};\nfunction getCoords(w, h, t) {\n    var xOffset = (w * t.k - w) / 2;\n    var yOffset = (h * t.k - h) / 2;\n    return [\n        w / 2 - (xOffset + t.x) / t.k,\n        h / 2 - (yOffset + t.y) / t.k\n    ];\n}\nfunction fetchGeographies(url) {\n    return fetch(url).then(function(res) {\n        if (!res.ok) {\n            throw Error(res.statusText);\n        }\n        return res.json();\n    })[\"catch\"](function(error) {\n        console.log(\"There was a problem when fetching the data: \", error);\n    });\n}\nfunction getFeatures(geographies, parseGeographies) {\n    var isTopojson = geographies.type === \"Topology\";\n    if (!isTopojson) {\n        return parseGeographies ? parseGeographies(geographies.features || geographies) : geographies.features || geographies;\n    }\n    var feats = topojsonClient.feature(geographies, geographies.objects[Object.keys(geographies.objects)[0]]).features;\n    return parseGeographies ? parseGeographies(feats) : feats;\n}\nfunction getMesh(geographies) {\n    var isTopojson = geographies.type === \"Topology\";\n    if (!isTopojson) return null;\n    var outline = topojsonClient.mesh(geographies, geographies.objects[Object.keys(geographies.objects)[0]], function(a, b) {\n        return a === b;\n    });\n    var borders = topojsonClient.mesh(geographies, geographies.objects[Object.keys(geographies.objects)[0]], function(a, b) {\n        return a !== b;\n    });\n    return {\n        outline: outline,\n        borders: borders\n    };\n}\nfunction prepareMesh(outline, borders, path) {\n    return outline && borders ? {\n        outline: _objectSpread2(_objectSpread2({}, outline), {}, {\n            rsmKey: \"outline\",\n            svgPath: path(outline)\n        }),\n        borders: _objectSpread2(_objectSpread2({}, borders), {}, {\n            rsmKey: \"borders\",\n            svgPath: path(borders)\n        })\n    } : {};\n}\nfunction prepareFeatures(geographies, path) {\n    return geographies ? geographies.map(function(d, i) {\n        return _objectSpread2(_objectSpread2({}, d), {}, {\n            rsmKey: \"geo-\".concat(i),\n            svgPath: path(d)\n        });\n    }) : [];\n}\nfunction createConnectorPath() {\n    var dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;\n    var dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    var curve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n    var curvature = Array.isArray(curve) ? curve : [\n        curve,\n        curve\n    ];\n    var curveX = dx / 2 * curvature[0];\n    var curveY = dy / 2 * curvature[1];\n    return \"M\".concat(0, \",\", 0, \" Q\", -dx / 2 - curveX, \",\").concat(-dy / 2 + curveY, \" \").concat(-dx, \",\").concat(-dy);\n}\nfunction isString(geo) {\n    return typeof geo === \"string\";\n}\nfunction useGeographies(_ref) {\n    var geography = _ref.geography, parseGeographies = _ref.parseGeographies;\n    var _useContext = React.useContext(MapContext), path = _useContext.path;\n    var _useState = React.useState({}), _useState2 = _slicedToArray(_useState, 2), output = _useState2[0], setOutput = _useState2[1];\n    React.useEffect(function() {\n        if (true) return;\n        if (!geography) return;\n        if (isString(geography)) {\n            fetchGeographies(geography).then(function(geos) {\n                if (geos) {\n                    setOutput({\n                        geographies: getFeatures(geos, parseGeographies),\n                        mesh: getMesh(geos)\n                    });\n                }\n            });\n        } else {\n            setOutput({\n                geographies: getFeatures(geography, parseGeographies),\n                mesh: getMesh(geography)\n            });\n        }\n    }, [\n        geography,\n        parseGeographies\n    ]);\n    var _useMemo = React.useMemo(function() {\n        var mesh = output.mesh || {};\n        var preparedMesh = prepareMesh(mesh.outline, mesh.borders, path);\n        return {\n            geographies: prepareFeatures(output.geographies, path),\n            outline: preparedMesh.outline,\n            borders: preparedMesh.borders\n        };\n    }, [\n        output,\n        path\n    ]), geographies = _useMemo.geographies, outline = _useMemo.outline, borders = _useMemo.borders;\n    return {\n        geographies: geographies,\n        outline: outline,\n        borders: borders\n    };\n}\nvar _excluded$8 = [\n    \"geography\",\n    \"children\",\n    \"parseGeographies\",\n    \"className\"\n];\nvar Geographies = React.forwardRef(function(_ref, ref) {\n    var geography = _ref.geography, children = _ref.children, parseGeographies = _ref.parseGeographies, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$8);\n    var _useContext = React.useContext(MapContext), path = _useContext.path, projection = _useContext.projection;\n    var _useGeographies = useGeographies({\n        geography: geography,\n        parseGeographies: parseGeographies\n    }), geographies = _useGeographies.geographies, outline = _useGeographies.outline, borders = _useGeographies.borders;\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"g\", _extends({\n        ref: ref,\n        className: \"rsm-geographies \".concat(className)\n    }, restProps), geographies && geographies.length > 0 && children({\n        geographies: geographies,\n        outline: outline,\n        borders: borders,\n        path: path,\n        projection: projection\n    }));\n});\nGeographies.displayName = \"Geographies\";\nGeographies.propTypes = {\n    geography: PropTypes__default[\"default\"].oneOfType([\n        PropTypes__default[\"default\"].string,\n        PropTypes__default[\"default\"].object,\n        PropTypes__default[\"default\"].array\n    ]),\n    children: PropTypes__default[\"default\"].func,\n    parseGeographies: PropTypes__default[\"default\"].func,\n    className: PropTypes__default[\"default\"].string\n};\nvar _excluded$7 = [\n    \"geography\",\n    \"onMouseEnter\",\n    \"onMouseLeave\",\n    \"onMouseDown\",\n    \"onMouseUp\",\n    \"onFocus\",\n    \"onBlur\",\n    \"style\",\n    \"className\"\n];\nvar Geography = React.forwardRef(function(_ref, ref) {\n    var geography = _ref.geography, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onFocus = _ref.onFocus, onBlur = _ref.onBlur, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$7);\n    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), isPressed = _useState2[0], setPressed = _useState2[1];\n    var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), isFocused = _useState4[0], setFocus = _useState4[1];\n    function handleMouseEnter(evt) {\n        setFocus(true);\n        if (onMouseEnter) onMouseEnter(evt);\n    }\n    function handleMouseLeave(evt) {\n        setFocus(false);\n        if (isPressed) setPressed(false);\n        if (onMouseLeave) onMouseLeave(evt);\n    }\n    function handleFocus(evt) {\n        setFocus(true);\n        if (onFocus) onFocus(evt);\n    }\n    function handleBlur(evt) {\n        setFocus(false);\n        if (isPressed) setPressed(false);\n        if (onBlur) onBlur(evt);\n    }\n    function handleMouseDown(evt) {\n        setPressed(true);\n        if (onMouseDown) onMouseDown(evt);\n    }\n    function handleMouseUp(evt) {\n        setPressed(false);\n        if (onMouseUp) onMouseUp(evt);\n    }\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", _extends({\n        ref: ref,\n        tabIndex: \"0\",\n        className: \"rsm-geography \".concat(className),\n        d: geography.svgPath,\n        onMouseEnter: handleMouseEnter,\n        onMouseLeave: handleMouseLeave,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onMouseDown: handleMouseDown,\n        onMouseUp: handleMouseUp,\n        style: style[isPressed || isFocused ? isPressed ? \"pressed\" : \"hover\" : \"default\"]\n    }, restProps));\n});\nGeography.displayName = \"Geography\";\nGeography.propTypes = {\n    geography: PropTypes__default[\"default\"].object,\n    onMouseEnter: PropTypes__default[\"default\"].func,\n    onMouseLeave: PropTypes__default[\"default\"].func,\n    onMouseDown: PropTypes__default[\"default\"].func,\n    onMouseUp: PropTypes__default[\"default\"].func,\n    onFocus: PropTypes__default[\"default\"].func,\n    onBlur: PropTypes__default[\"default\"].func,\n    style: PropTypes__default[\"default\"].object,\n    className: PropTypes__default[\"default\"].string\n};\nvar Geography$1 = React.memo(Geography);\nvar _excluded$6 = [\n    \"fill\",\n    \"stroke\",\n    \"step\",\n    \"className\"\n];\nvar Graticule = React.forwardRef(function(_ref, ref) {\n    var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? \"transparent\" : _ref$fill, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? \"currentcolor\" : _ref$stroke, _ref$step = _ref.step, step = _ref$step === void 0 ? [\n        10,\n        10\n    ] : _ref$step, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$6);\n    var _useContext = React.useContext(MapContext), path = _useContext.path;\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", _extends({\n        ref: ref,\n        d: path(d3Geo.geoGraticule().step(step)()),\n        fill: fill,\n        stroke: stroke,\n        className: \"rsm-graticule \".concat(className)\n    }, restProps));\n});\nGraticule.displayName = \"Graticule\";\nGraticule.propTypes = {\n    fill: PropTypes__default[\"default\"].string,\n    stroke: PropTypes__default[\"default\"].string,\n    step: PropTypes__default[\"default\"].array,\n    className: PropTypes__default[\"default\"].string\n};\nvar Graticule$1 = React.memo(Graticule);\nvar _excluded$5 = [\n    \"value\"\n];\nvar ZoomPanContext = React.createContext();\nvar defaultValue = {\n    x: 0,\n    y: 0,\n    k: 1,\n    transformString: \"translate(0 0) scale(1)\"\n};\nvar ZoomPanProvider = function ZoomPanProvider(_ref) {\n    var _ref$value = _ref.value, value = _ref$value === void 0 ? defaultValue : _ref$value, restProps = _objectWithoutProperties(_ref, _excluded$5);\n    return /*#__PURE__*/ React__default[\"default\"].createElement(ZoomPanContext.Provider, _extends({\n        value: value\n    }, restProps));\n};\nZoomPanProvider.propTypes = {\n    x: PropTypes__default[\"default\"].number,\n    y: PropTypes__default[\"default\"].number,\n    k: PropTypes__default[\"default\"].number,\n    transformString: PropTypes__default[\"default\"].string\n};\nvar useZoomPanContext = function useZoomPanContext() {\n    return React.useContext(ZoomPanContext);\n};\nfunction useZoomPan(_ref) {\n    var center = _ref.center, filterZoomEvent = _ref.filterZoomEvent, onMoveStart = _ref.onMoveStart, onMoveEnd = _ref.onMoveEnd, onMove = _ref.onMove, _ref$translateExtent = _ref.translateExtent, translateExtent = _ref$translateExtent === void 0 ? [\n        [\n            -Infinity,\n            -Infinity\n        ],\n        [\n            Infinity,\n            Infinity\n        ]\n    ] : _ref$translateExtent, _ref$scaleExtent = _ref.scaleExtent, scaleExtent = _ref$scaleExtent === void 0 ? [\n        1,\n        8\n    ] : _ref$scaleExtent, _ref$zoom = _ref.zoom, zoom = _ref$zoom === void 0 ? 1 : _ref$zoom;\n    var _useContext = React.useContext(MapContext), width = _useContext.width, height = _useContext.height, projection = _useContext.projection;\n    var _center = _slicedToArray(center, 2), lon = _center[0], lat = _center[1];\n    var _useState = React.useState({\n        x: 0,\n        y: 0,\n        k: 1\n    }), _useState2 = _slicedToArray(_useState, 2), position = _useState2[0], setPosition = _useState2[1];\n    var lastPosition = React.useRef({\n        x: 0,\n        y: 0,\n        k: 1\n    });\n    var mapRef = React.useRef();\n    var zoomRef = React.useRef();\n    var bypassEvents = React.useRef(false);\n    var _translateExtent = _slicedToArray(translateExtent, 2), a = _translateExtent[0], b = _translateExtent[1];\n    var _a = _slicedToArray(a, 2), a1 = _a[0], a2 = _a[1];\n    var _b = _slicedToArray(b, 2), b1 = _b[0], b2 = _b[1];\n    var _scaleExtent = _slicedToArray(scaleExtent, 2), minZoom = _scaleExtent[0], maxZoom = _scaleExtent[1];\n    React.useEffect(function() {\n        var svg = d3Selection.select(mapRef.current);\n        function handleZoomStart(d3Event) {\n            if (!onMoveStart || bypassEvents.current) return;\n            onMoveStart({\n                coordinates: projection.invert(getCoords(width, height, d3Event.transform)),\n                zoom: d3Event.transform.k\n            }, d3Event);\n        }\n        function handleZoom(d3Event) {\n            if (bypassEvents.current) return;\n            var transform = d3Event.transform, sourceEvent = d3Event.sourceEvent;\n            setPosition({\n                x: transform.x,\n                y: transform.y,\n                k: transform.k,\n                dragging: sourceEvent\n            });\n            if (!onMove) return;\n            onMove({\n                x: transform.x,\n                y: transform.y,\n                zoom: transform.k,\n                dragging: sourceEvent\n            }, d3Event);\n        }\n        function handleZoomEnd(d3Event) {\n            if (bypassEvents.current) {\n                bypassEvents.current = false;\n                return;\n            }\n            var _projection$invert = projection.invert(getCoords(width, height, d3Event.transform)), _projection$invert2 = _slicedToArray(_projection$invert, 2), x = _projection$invert2[0], y = _projection$invert2[1];\n            lastPosition.current = {\n                x: x,\n                y: y,\n                k: d3Event.transform.k\n            };\n            if (!onMoveEnd) return;\n            onMoveEnd({\n                coordinates: [\n                    x,\n                    y\n                ],\n                zoom: d3Event.transform.k\n            }, d3Event);\n        }\n        function filterFunc(d3Event) {\n            if (filterZoomEvent) {\n                return filterZoomEvent(d3Event);\n            }\n            return d3Event ? !d3Event.ctrlKey && !d3Event.button : false;\n        }\n        var zoom = d3Zoom.zoom().filter(filterFunc).scaleExtent([\n            minZoom,\n            maxZoom\n        ]).translateExtent([\n            [\n                a1,\n                a2\n            ],\n            [\n                b1,\n                b2\n            ]\n        ]).on(\"start\", handleZoomStart).on(\"zoom\", handleZoom).on(\"end\", handleZoomEnd);\n        zoomRef.current = zoom;\n        svg.call(zoom);\n    }, [\n        width,\n        height,\n        a1,\n        a2,\n        b1,\n        b2,\n        minZoom,\n        maxZoom,\n        projection,\n        onMoveStart,\n        onMove,\n        onMoveEnd,\n        filterZoomEvent\n    ]);\n    React.useEffect(function() {\n        if (lon === lastPosition.current.x && lat === lastPosition.current.y && zoom === lastPosition.current.k) return;\n        var coords = projection([\n            lon,\n            lat\n        ]);\n        var x = coords[0] * zoom;\n        var y = coords[1] * zoom;\n        var svg = d3Selection.select(mapRef.current);\n        bypassEvents.current = true;\n        svg.call(zoomRef.current.transform, d3Zoom.zoomIdentity.translate(width / 2 - x, height / 2 - y).scale(zoom));\n        setPosition({\n            x: width / 2 - x,\n            y: height / 2 - y,\n            k: zoom\n        });\n        lastPosition.current = {\n            x: lon,\n            y: lat,\n            k: zoom\n        };\n    }, [\n        lon,\n        lat,\n        zoom,\n        width,\n        height,\n        projection\n    ]);\n    return {\n        mapRef: mapRef,\n        position: position,\n        transformString: \"translate(\".concat(position.x, \" \").concat(position.y, \") scale(\").concat(position.k, \")\")\n    };\n}\nvar _excluded$4 = [\n    \"center\",\n    \"zoom\",\n    \"minZoom\",\n    \"maxZoom\",\n    \"translateExtent\",\n    \"filterZoomEvent\",\n    \"onMoveStart\",\n    \"onMove\",\n    \"onMoveEnd\",\n    \"className\"\n];\nvar ZoomableGroup = React.forwardRef(function(_ref, ref) {\n    var _ref$center = _ref.center, center = _ref$center === void 0 ? [\n        0,\n        0\n    ] : _ref$center, _ref$zoom = _ref.zoom, zoom = _ref$zoom === void 0 ? 1 : _ref$zoom, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? 1 : _ref$minZoom, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? 8 : _ref$maxZoom, translateExtent = _ref.translateExtent, filterZoomEvent = _ref.filterZoomEvent, onMoveStart = _ref.onMoveStart, onMove = _ref.onMove, onMoveEnd = _ref.onMoveEnd, className = _ref.className, restProps = _objectWithoutProperties(_ref, _excluded$4);\n    var _useContext = React.useContext(MapContext), width = _useContext.width, height = _useContext.height;\n    var _useZoomPan = useZoomPan({\n        center: center,\n        filterZoomEvent: filterZoomEvent,\n        onMoveStart: onMoveStart,\n        onMove: onMove,\n        onMoveEnd: onMoveEnd,\n        scaleExtent: [\n            minZoom,\n            maxZoom\n        ],\n        translateExtent: translateExtent,\n        zoom: zoom\n    }), mapRef = _useZoomPan.mapRef, transformString = _useZoomPan.transformString, position = _useZoomPan.position;\n    return /*#__PURE__*/ React__default[\"default\"].createElement(ZoomPanProvider, {\n        value: {\n            x: position.x,\n            y: position.y,\n            k: position.k,\n            transformString: transformString\n        }\n    }, /*#__PURE__*/ React__default[\"default\"].createElement(\"g\", {\n        ref: mapRef\n    }, /*#__PURE__*/ React__default[\"default\"].createElement(\"rect\", {\n        width: width,\n        height: height,\n        fill: \"transparent\"\n    }), /*#__PURE__*/ React__default[\"default\"].createElement(\"g\", _extends({\n        ref: ref,\n        transform: transformString,\n        className: \"rsm-zoomable-group \".concat(className)\n    }, restProps))));\n});\nZoomableGroup.displayName = \"ZoomableGroup\";\nZoomableGroup.propTypes = {\n    center: PropTypes__default[\"default\"].array,\n    zoom: PropTypes__default[\"default\"].number,\n    minZoom: PropTypes__default[\"default\"].number,\n    maxZoom: PropTypes__default[\"default\"].number,\n    translateExtent: PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].array),\n    onMoveStart: PropTypes__default[\"default\"].func,\n    onMove: PropTypes__default[\"default\"].func,\n    onMoveEnd: PropTypes__default[\"default\"].func,\n    className: PropTypes__default[\"default\"].string\n};\nvar _excluded$3 = [\n    \"id\",\n    \"fill\",\n    \"stroke\",\n    \"strokeWidth\",\n    \"className\"\n];\nvar Sphere = React.forwardRef(function(_ref, ref) {\n    var _ref$id = _ref.id, id = _ref$id === void 0 ? \"rsm-sphere\" : _ref$id, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? \"transparent\" : _ref$fill, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? \"currentcolor\" : _ref$stroke, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 0.5 : _ref$strokeWidth, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$3);\n    var _useContext = React.useContext(MapContext), path = _useContext.path;\n    var spherePath = React.useMemo(function() {\n        return path({\n            type: \"Sphere\"\n        });\n    }, [\n        path\n    ]);\n    return /*#__PURE__*/ React__default[\"default\"].createElement(React.Fragment, null, /*#__PURE__*/ React__default[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ React__default[\"default\"].createElement(\"clipPath\", {\n        id: id\n    }, /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", {\n        d: spherePath\n    }))), /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", _extends({\n        ref: ref,\n        d: spherePath,\n        fill: fill,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        style: {\n            pointerEvents: \"none\"\n        },\n        className: \"rsm-sphere \".concat(className)\n    }, restProps)));\n});\nSphere.displayName = \"Sphere\";\nSphere.propTypes = {\n    id: PropTypes__default[\"default\"].string,\n    fill: PropTypes__default[\"default\"].string,\n    stroke: PropTypes__default[\"default\"].string,\n    strokeWidth: PropTypes__default[\"default\"].number,\n    className: PropTypes__default[\"default\"].string\n};\nvar Sphere$1 = React.memo(Sphere);\nvar _excluded$2 = [\n    \"coordinates\",\n    \"children\",\n    \"onMouseEnter\",\n    \"onMouseLeave\",\n    \"onMouseDown\",\n    \"onMouseUp\",\n    \"onFocus\",\n    \"onBlur\",\n    \"style\",\n    \"className\"\n];\nvar Marker = React.forwardRef(function(_ref, ref) {\n    var coordinates = _ref.coordinates, children = _ref.children, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onFocus = _ref.onFocus, onBlur = _ref.onBlur, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$2);\n    var _useContext = React.useContext(MapContext), projection = _useContext.projection;\n    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), isPressed = _useState2[0], setPressed = _useState2[1];\n    var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), isFocused = _useState4[0], setFocus = _useState4[1];\n    var _projection = projection(coordinates), _projection2 = _slicedToArray(_projection, 2), x = _projection2[0], y = _projection2[1];\n    function handleMouseEnter(evt) {\n        setFocus(true);\n        if (onMouseEnter) onMouseEnter(evt);\n    }\n    function handleMouseLeave(evt) {\n        setFocus(false);\n        if (isPressed) setPressed(false);\n        if (onMouseLeave) onMouseLeave(evt);\n    }\n    function handleFocus(evt) {\n        setFocus(true);\n        if (onFocus) onFocus(evt);\n    }\n    function handleBlur(evt) {\n        setFocus(false);\n        if (isPressed) setPressed(false);\n        if (onBlur) onBlur(evt);\n    }\n    function handleMouseDown(evt) {\n        setPressed(true);\n        if (onMouseDown) onMouseDown(evt);\n    }\n    function handleMouseUp(evt) {\n        setPressed(false);\n        if (onMouseUp) onMouseUp(evt);\n    }\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"g\", _extends({\n        ref: ref,\n        transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n        className: \"rsm-marker \".concat(className),\n        onMouseEnter: handleMouseEnter,\n        onMouseLeave: handleMouseLeave,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onMouseDown: handleMouseDown,\n        onMouseUp: handleMouseUp,\n        style: style[isPressed || isFocused ? isPressed ? \"pressed\" : \"hover\" : \"default\"]\n    }, restProps), children);\n});\nMarker.displayName = \"Marker\";\nMarker.propTypes = {\n    coordinates: PropTypes__default[\"default\"].array,\n    children: PropTypes__default[\"default\"].oneOfType([\n        PropTypes__default[\"default\"].node,\n        PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].node)\n    ]),\n    onMouseEnter: PropTypes__default[\"default\"].func,\n    onMouseLeave: PropTypes__default[\"default\"].func,\n    onMouseDown: PropTypes__default[\"default\"].func,\n    onMouseUp: PropTypes__default[\"default\"].func,\n    onFocus: PropTypes__default[\"default\"].func,\n    onBlur: PropTypes__default[\"default\"].func,\n    style: PropTypes__default[\"default\"].object,\n    className: PropTypes__default[\"default\"].string\n};\nvar _excluded$1 = [\n    \"from\",\n    \"to\",\n    \"coordinates\",\n    \"stroke\",\n    \"strokeWidth\",\n    \"fill\",\n    \"className\"\n];\nvar Line = React.forwardRef(function(_ref, ref) {\n    var _ref$from = _ref.from, from = _ref$from === void 0 ? [\n        0,\n        0\n    ] : _ref$from, _ref$to = _ref.to, to = _ref$to === void 0 ? [\n        0,\n        0\n    ] : _ref$to, coordinates = _ref.coordinates, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? \"currentcolor\" : _ref$stroke, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 3 : _ref$strokeWidth, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? \"transparent\" : _ref$fill, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded$1);\n    var _useContext = React.useContext(MapContext), path = _useContext.path;\n    var lineData = {\n        type: \"LineString\",\n        coordinates: coordinates || [\n            from,\n            to\n        ]\n    };\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", _extends({\n        ref: ref,\n        d: path(lineData),\n        className: \"rsm-line \".concat(className),\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        fill: fill\n    }, restProps));\n});\nLine.displayName = \"Line\";\nLine.propTypes = {\n    from: PropTypes__default[\"default\"].array,\n    to: PropTypes__default[\"default\"].array,\n    coordinates: PropTypes__default[\"default\"].array,\n    stroke: PropTypes__default[\"default\"].string,\n    strokeWidth: PropTypes__default[\"default\"].number,\n    fill: PropTypes__default[\"default\"].string,\n    className: PropTypes__default[\"default\"].string\n};\nvar _excluded = [\n    \"subject\",\n    \"children\",\n    \"connectorProps\",\n    \"dx\",\n    \"dy\",\n    \"curve\",\n    \"className\"\n];\nvar Annotation = React.forwardRef(function(_ref, ref) {\n    var subject = _ref.subject, children = _ref.children, connectorProps = _ref.connectorProps, _ref$dx = _ref.dx, dx = _ref$dx === void 0 ? 30 : _ref$dx, _ref$dy = _ref.dy, dy = _ref$dy === void 0 ? 30 : _ref$dy, _ref$curve = _ref.curve, curve = _ref$curve === void 0 ? 0 : _ref$curve, _ref$className = _ref.className, className = _ref$className === void 0 ? \"\" : _ref$className, restProps = _objectWithoutProperties(_ref, _excluded);\n    var _useContext = React.useContext(MapContext), projection = _useContext.projection;\n    var _projection = projection(subject), _projection2 = _slicedToArray(_projection, 2), x = _projection2[0], y = _projection2[1];\n    var connectorPath = createConnectorPath(dx, dy, curve);\n    return /*#__PURE__*/ React__default[\"default\"].createElement(\"g\", _extends({\n        ref: ref,\n        transform: \"translate(\".concat(x + dx, \", \").concat(y + dy, \")\"),\n        className: \"rsm-annotation \".concat(className)\n    }, restProps), /*#__PURE__*/ React__default[\"default\"].createElement(\"path\", _extends({\n        d: connectorPath,\n        fill: \"transparent\",\n        stroke: \"#000\"\n    }, connectorProps)), children);\n});\nAnnotation.displayName = \"Annotation\";\nAnnotation.propTypes = {\n    subject: PropTypes__default[\"default\"].array,\n    children: PropTypes__default[\"default\"].oneOfType([\n        PropTypes__default[\"default\"].node,\n        PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].node)\n    ]),\n    dx: PropTypes__default[\"default\"].number,\n    dy: PropTypes__default[\"default\"].number,\n    curve: PropTypes__default[\"default\"].number,\n    connectorProps: PropTypes__default[\"default\"].object,\n    className: PropTypes__default[\"default\"].string\n};\nexports.Annotation = Annotation;\nexports.ComposableMap = ComposableMap;\nexports.Geographies = Geographies;\nexports.Geography = Geography$1;\nexports.Graticule = Graticule$1;\nexports.Line = Line;\nexports.MapContext = MapContext;\nexports.MapProvider = MapProvider;\nexports.Marker = Marker;\nexports.Sphere = Sphere$1;\nexports.ZoomPanContext = ZoomPanContext;\nexports.ZoomPanProvider = ZoomPanProvider;\nexports.ZoomableGroup = ZoomableGroup;\nexports.useGeographies = useGeographies;\nexports.useMapContext = useMapContext;\nexports.useZoomPan = useZoomPan;\nexports.useZoomPanContext = useZoomPanContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLW1hcHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxpQkFBaUJILG1CQUFPQSxDQUFDO0FBQzdCLElBQUlJLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlLLGNBQWNMLG1CQUFPQSxDQUFDO0FBRTFCLFNBQVNNLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsU0FBU0Msa0JBQWtCRCxDQUFDO0lBQzFCLElBQUlBLEtBQUtBLEVBQUVFLFVBQVUsRUFBRSxPQUFPRjtJQUM5QixJQUFJRyxJQUFJZixPQUFPZ0IsTUFBTSxDQUFDO0lBQ3RCLElBQUlKLEdBQUc7UUFDTFosT0FBT2lCLElBQUksQ0FBQ0wsR0FBR00sT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDaEMsSUFBSUEsTUFBTSxXQUFXO2dCQUNuQixJQUFJQyxJQUFJcEIsT0FBT3FCLHdCQUF3QixDQUFDVCxHQUFHTztnQkFDM0NuQixPQUFPQyxjQUFjLENBQUNjLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1YsQ0FBQyxDQUFDTyxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHSDtJQUNmLE9BQU9aLE9BQU93QixNQUFNLENBQUNUO0FBQ3ZCO0FBRUEsSUFBSVUsaUJBQWlCLFdBQVcsR0FBRWQsc0JBQXNCUDtBQUN4RCxJQUFJc0IscUJBQXFCLFdB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RCxJQUFJOUssa0JBQWtCLENBQUMsVUFBVSxDQUFDb0gsTUFBTTtJQUN4QzJELE9BQU8vSyxrQkFBa0IsQ0FBQyxVQUFVLENBQUNvSCxNQUFNO0lBQzNDaU4sZ0JBQWdCclUsa0JBQWtCLENBQUMsVUFBVSxDQUFDRyxNQUFNO0lBQ3BENEgsV0FBVy9ILGtCQUFrQixDQUFDLFVBQVUsQ0FBQ3NILE1BQU07QUFDakQ7QUFFQTlJLGtCQUFrQixHQUFHMlY7QUFDckIzVixxQkFBcUIsR0FBR21KO0FBQ3hCbkosbUJBQW1CLEdBQUcyTjtBQUN0QjNOLGlCQUFpQixHQUFHdVA7QUFDcEJ2UCxpQkFBaUIsR0FBR2tRO0FBQ3BCbFEsWUFBWSxHQUFHcVY7QUFDZnJWLGtCQUFrQixHQUFHZ0c7QUFDckJoRyxtQkFBbUIsR0FBR29IO0FBQ3RCcEgsY0FBYyxHQUFHZ1Y7QUFDakJoVixjQUFjLEdBQUc4VTtBQUNqQjlVLHNCQUFzQixHQUFHb1E7QUFDekJwUSx1QkFBdUIsR0FBR3VRO0FBQzFCdlEscUJBQXFCLEdBQUcrVDtBQUN4Qi9ULHNCQUFzQixHQUFHNk07QUFDekI3TSxxQkFBcUIsR0FBR2dKO0FBQ3hCaEosa0JBQWtCLEdBQUcwUTtBQUNyQjFRLHlCQUF5QixHQUFHeVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JsZC1rcGktZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNpbXBsZS1tYXBzL2Rpc3QvaW5kZXguanM/ZmQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xudmFyIGQzR2VvID0gcmVxdWlyZSgnZDMtZ2VvJyk7XG52YXIgdG9wb2pzb25DbGllbnQgPSByZXF1aXJlKCd0b3BvanNvbi1jbGllbnQnKTtcbnZhciBkM1pvb20gPSByZXF1aXJlKCdkMy16b29tJyk7XG52YXIgZDNTZWxlY3Rpb24gPSByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xudmFyIFByb3BUeXBlc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUHJvcFR5cGVzKTtcbnZhciBkM0dlb19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKGQzR2VvKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBfZXhjbHVkZWQkYSA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicHJvamVjdGlvblwiLCBcInByb2plY3Rpb25Db25maWdcIl07XG5cbnZhciBnZW9QYXRoID0gZDNHZW9fX25hbWVzcGFjZS5nZW9QYXRoLFxuICAgIHByb2plY3Rpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGQzR2VvX19uYW1lc3BhY2UsIFtcImdlb1BhdGhcIl0pO1xuXG52YXIgTWFwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoKTtcblxudmFyIG1ha2VQcm9qZWN0aW9uID0gZnVuY3Rpb24gbWFrZVByb2plY3Rpb24oX3JlZikge1xuICB2YXIgX3JlZiRwcm9qZWN0aW9uQ29uZmlnID0gX3JlZi5wcm9qZWN0aW9uQ29uZmlnLFxuICAgICAgcHJvamVjdGlvbkNvbmZpZyA9IF9yZWYkcHJvamVjdGlvbkNvbmZpZyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHByb2plY3Rpb25Db25maWcsXG4gICAgICBfcmVmJHByb2plY3Rpb24gPSBfcmVmLnByb2plY3Rpb24sXG4gICAgICBwcm9qZWN0aW9uID0gX3JlZiRwcm9qZWN0aW9uID09PSB2b2lkIDAgPyBcImdlb0VxdWFsRWFydGhcIiA6IF9yZWYkcHJvamVjdGlvbixcbiAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB2b2lkIDAgPyA4MDAgOiBfcmVmJHdpZHRoLFxuICAgICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGhlaWdodCA9IF9yZWYkaGVpZ2h0ID09PSB2b2lkIDAgPyA2MDAgOiBfcmVmJGhlaWdodDtcbiAgdmFyIGlzRnVuYyA9IHR5cGVvZiBwcm9qZWN0aW9uID09PSBcImZ1bmN0aW9uXCI7XG4gIGlmIChpc0Z1bmMpIHJldHVybiBwcm9qZWN0aW9uO1xuICB2YXIgcHJvaiA9IHByb2plY3Rpb25zW3Byb2plY3Rpb25dKCkudHJhbnNsYXRlKFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdKTtcbiAgdmFyIHN1cHBvcnRlZCA9IFtwcm9qLmNlbnRlciA/IFwiY2VudGVyXCIgOiBudWxsLCBwcm9qLnJvdGF0ZSA/IFwicm90YXRlXCIgOiBudWxsLCBwcm9qLnNjYWxlID8gXCJzY2FsZVwiIDogbnVsbCwgcHJvai5wYXJhbGxlbHMgPyBcInBhcmFsbGVsc1wiIDogbnVsbF07XG4gIHN1cHBvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKCFkKSByZXR1cm47XG4gICAgcHJvaiA9IHByb2pbZF0ocHJvamVjdGlvbkNvbmZpZ1tkXSB8fCBwcm9qW2RdKCkpO1xuICB9KTtcbiAgcmV0dXJuIHByb2o7XG59O1xuXG52YXIgTWFwUHJvdmlkZXIgPSBmdW5jdGlvbiBNYXBQcm92aWRlcihfcmVmMikge1xuICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgIHByb2plY3Rpb24gPSBfcmVmMi5wcm9qZWN0aW9uLFxuICAgICAgcHJvamVjdGlvbkNvbmZpZyA9IF9yZWYyLnByb2plY3Rpb25Db25maWcsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIF9leGNsdWRlZCRhKTtcblxuICB2YXIgX3JlZjMgPSBwcm9qZWN0aW9uQ29uZmlnLmNlbnRlciB8fCBbXSxcbiAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgY3ggPSBfcmVmNFswXSxcbiAgICAgIGN5ID0gX3JlZjRbMV07XG5cbiAgdmFyIF9yZWY1ID0gcHJvamVjdGlvbkNvbmZpZy5yb3RhdGUgfHwgW10sXG4gICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAzKSxcbiAgICAgIHJ4ID0gX3JlZjZbMF0sXG4gICAgICByeSA9IF9yZWY2WzFdLFxuICAgICAgcnogPSBfcmVmNlsyXTtcblxuICB2YXIgX3JlZjcgPSBwcm9qZWN0aW9uQ29uZmlnLnBhcmFsbGVscyB8fCBbXSxcbiAgICAgIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgICAgcDEgPSBfcmVmOFswXSxcbiAgICAgIHAyID0gX3JlZjhbMV07XG5cbiAgdmFyIHMgPSBwcm9qZWN0aW9uQ29uZmlnLnNjYWxlIHx8IG51bGw7XG4gIHZhciBwcm9qTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYWtlUHJvamVjdGlvbih7XG4gICAgICBwcm9qZWN0aW9uQ29uZmlnOiB7XG4gICAgICAgIGNlbnRlcjogY3ggfHwgY3ggPT09IDAgfHwgY3kgfHwgY3kgPT09IDAgPyBbY3gsIGN5XSA6IG51bGwsXG4gICAgICAgIHJvdGF0ZTogcnggfHwgcnggPT09IDAgfHwgcnkgfHwgcnkgPT09IDAgPyBbcngsIHJ5LCByel0gOiBudWxsLFxuICAgICAgICBwYXJhbGxlbHM6IHAxIHx8IHAxID09PSAwIHx8IHAyIHx8IHAyID09PSAwID8gW3AxLCBwMl0gOiBudWxsLFxuICAgICAgICBzY2FsZTogc1xuICAgICAgfSxcbiAgICAgIHByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0pO1xuICB9LCBbd2lkdGgsIGhlaWdodCwgcHJvamVjdGlvbiwgY3gsIGN5LCByeCwgcnksIHJ6LCBwMSwgcDIsIHNdKTtcbiAgdmFyIHByb2ogPSBSZWFjdC51c2VDYWxsYmFjayhwcm9qTWVtbywgW3Byb2pNZW1vXSk7XG4gIHZhciB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHByb2plY3Rpb246IHByb2osXG4gICAgICBwYXRoOiBnZW9QYXRoKCkucHJvamVjdGlvbihwcm9qKVxuICAgIH07XG4gIH0sIFt3aWR0aCwgaGVpZ2h0LCBwcm9qXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dC5Qcm92aWRlciwgX2V4dGVuZHMoe1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCByZXN0UHJvcHMpKTtcbn07XG5cbk1hcFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBwcm9qZWN0aW9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuICBwcm9qZWN0aW9uQ29uZmlnOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdFxufTtcblxudmFyIHVzZU1hcENvbnRleHQgPSBmdW5jdGlvbiB1c2VNYXBDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbn07XG5cbnZhciBfZXhjbHVkZWQkOSA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicHJvamVjdGlvblwiLCBcInByb2plY3Rpb25Db25maWdcIiwgXCJjbGFzc05hbWVcIl07XG52YXIgQ29tcG9zYWJsZU1hcCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgX3JlZiR3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICB3aWR0aCA9IF9yZWYkd2lkdGggPT09IHZvaWQgMCA/IDgwMCA6IF9yZWYkd2lkdGgsXG4gICAgICBfcmVmJGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgaGVpZ2h0ID0gX3JlZiRoZWlnaHQgPT09IHZvaWQgMCA/IDYwMCA6IF9yZWYkaGVpZ2h0LFxuICAgICAgX3JlZiRwcm9qZWN0aW9uID0gX3JlZi5wcm9qZWN0aW9uLFxuICAgICAgcHJvamVjdGlvbiA9IF9yZWYkcHJvamVjdGlvbiA9PT0gdm9pZCAwID8gXCJnZW9FcXVhbEVhcnRoXCIgOiBfcmVmJHByb2plY3Rpb24sXG4gICAgICBfcmVmJHByb2plY3Rpb25Db25maWcgPSBfcmVmLnByb2plY3Rpb25Db25maWcsXG4gICAgICBwcm9qZWN0aW9uQ29uZmlnID0gX3JlZiRwcm9qZWN0aW9uQ29uZmlnID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkcHJvamVjdGlvbkNvbmZpZyxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQ5KTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KE1hcFByb3ZpZGVyLCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgcHJvamVjdGlvbkNvbmZpZzogcHJvamVjdGlvbkNvbmZpZ1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpLFxuICAgIGNsYXNzTmFtZTogXCJyc20tc3ZnIFwiLmNvbmNhdChjbGFzc05hbWUpXG4gIH0sIHJlc3RQcm9wcykpKTtcbn0pO1xuQ29tcG9zYWJsZU1hcC5kaXNwbGF5TmFtZSA9IFwiQ29tcG9zYWJsZU1hcFwiO1xuQ29tcG9zYWJsZU1hcC5wcm9wVHlwZXMgPSB7XG4gIHdpZHRoOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgcHJvamVjdGlvbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNdKSxcbiAgcHJvamVjdGlvbkNvbmZpZzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG5cbmZ1bmN0aW9uIGdldENvb3Jkcyh3LCBoLCB0KSB7XG4gIHZhciB4T2Zmc2V0ID0gKHcgKiB0LmsgLSB3KSAvIDI7XG4gIHZhciB5T2Zmc2V0ID0gKGggKiB0LmsgLSBoKSAvIDI7XG4gIHJldHVybiBbdyAvIDIgLSAoeE9mZnNldCArIHQueCkgLyB0LmssIGggLyAyIC0gKHlPZmZzZXQgKyB0LnkpIC8gdC5rXTtcbn1cbmZ1bmN0aW9uIGZldGNoR2VvZ3JhcGhpZXModXJsKSB7XG4gIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBFcnJvcihyZXMuc3RhdHVzVGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coXCJUaGVyZSB3YXMgYSBwcm9ibGVtIHdoZW4gZmV0Y2hpbmcgdGhlIGRhdGE6IFwiLCBlcnJvcik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmVhdHVyZXMoZ2VvZ3JhcGhpZXMsIHBhcnNlR2VvZ3JhcGhpZXMpIHtcbiAgdmFyIGlzVG9wb2pzb24gPSBnZW9ncmFwaGllcy50eXBlID09PSBcIlRvcG9sb2d5XCI7XG5cbiAgaWYgKCFpc1RvcG9qc29uKSB7XG4gICAgcmV0dXJuIHBhcnNlR2VvZ3JhcGhpZXMgPyBwYXJzZUdlb2dyYXBoaWVzKGdlb2dyYXBoaWVzLmZlYXR1cmVzIHx8IGdlb2dyYXBoaWVzKSA6IGdlb2dyYXBoaWVzLmZlYXR1cmVzIHx8IGdlb2dyYXBoaWVzO1xuICB9XG5cbiAgdmFyIGZlYXRzID0gdG9wb2pzb25DbGllbnQuZmVhdHVyZShnZW9ncmFwaGllcywgZ2VvZ3JhcGhpZXMub2JqZWN0c1tPYmplY3Qua2V5cyhnZW9ncmFwaGllcy5vYmplY3RzKVswXV0pLmZlYXR1cmVzO1xuICByZXR1cm4gcGFyc2VHZW9ncmFwaGllcyA/IHBhcnNlR2VvZ3JhcGhpZXMoZmVhdHMpIDogZmVhdHM7XG59XG5mdW5jdGlvbiBnZXRNZXNoKGdlb2dyYXBoaWVzKSB7XG4gIHZhciBpc1RvcG9qc29uID0gZ2VvZ3JhcGhpZXMudHlwZSA9PT0gXCJUb3BvbG9neVwiO1xuICBpZiAoIWlzVG9wb2pzb24pIHJldHVybiBudWxsO1xuICB2YXIgb3V0bGluZSA9IHRvcG9qc29uQ2xpZW50Lm1lc2goZ2VvZ3JhcGhpZXMsIGdlb2dyYXBoaWVzLm9iamVjdHNbT2JqZWN0LmtleXMoZ2VvZ3JhcGhpZXMub2JqZWN0cylbMF1dLCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9KTtcbiAgdmFyIGJvcmRlcnMgPSB0b3BvanNvbkNsaWVudC5tZXNoKGdlb2dyYXBoaWVzLCBnZW9ncmFwaGllcy5vYmplY3RzW09iamVjdC5rZXlzKGdlb2dyYXBoaWVzLm9iamVjdHMpWzBdXSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPT0gYjtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb3V0bGluZTogb3V0bGluZSxcbiAgICBib3JkZXJzOiBib3JkZXJzXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlTWVzaChvdXRsaW5lLCBib3JkZXJzLCBwYXRoKSB7XG4gIHJldHVybiBvdXRsaW5lICYmIGJvcmRlcnMgPyB7XG4gICAgb3V0bGluZTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG91dGxpbmUpLCB7fSwge1xuICAgICAgcnNtS2V5OiBcIm91dGxpbmVcIixcbiAgICAgIHN2Z1BhdGg6IHBhdGgob3V0bGluZSlcbiAgICB9KSxcbiAgICBib3JkZXJzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYm9yZGVycyksIHt9LCB7XG4gICAgICByc21LZXk6IFwiYm9yZGVyc1wiLFxuICAgICAgc3ZnUGF0aDogcGF0aChib3JkZXJzKVxuICAgIH0pXG4gIH0gOiB7fTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGZWF0dXJlcyhnZW9ncmFwaGllcywgcGF0aCkge1xuICByZXR1cm4gZ2VvZ3JhcGhpZXMgPyBnZW9ncmFwaGllcy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGQpLCB7fSwge1xuICAgICAgcnNtS2V5OiBcImdlby1cIi5jb25jYXQoaSksXG4gICAgICBzdmdQYXRoOiBwYXRoKGQpXG4gICAgfSk7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0b3JQYXRoKCkge1xuICB2YXIgZHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDMwO1xuICB2YXIgZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDMwO1xuICB2YXIgY3VydmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDAuNTtcbiAgdmFyIGN1cnZhdHVyZSA9IEFycmF5LmlzQXJyYXkoY3VydmUpID8gY3VydmUgOiBbY3VydmUsIGN1cnZlXTtcbiAgdmFyIGN1cnZlWCA9IGR4IC8gMiAqIGN1cnZhdHVyZVswXTtcbiAgdmFyIGN1cnZlWSA9IGR5IC8gMiAqIGN1cnZhdHVyZVsxXTtcbiAgcmV0dXJuIFwiTVwiLmNvbmNhdCgwLCBcIixcIiwgMCwgXCIgUVwiLCAtZHggLyAyIC0gY3VydmVYLCBcIixcIikuY29uY2F0KC1keSAvIDIgKyBjdXJ2ZVksIFwiIFwiKS5jb25jYXQoLWR4LCBcIixcIikuY29uY2F0KC1keSk7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhnZW8pIHtcbiAgcmV0dXJuIHR5cGVvZiBnZW8gPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIHVzZUdlb2dyYXBoaWVzKF9yZWYpIHtcbiAgdmFyIGdlb2dyYXBoeSA9IF9yZWYuZ2VvZ3JhcGh5LFxuICAgICAgcGFyc2VHZW9ncmFwaGllcyA9IF9yZWYucGFyc2VHZW9ncmFwaGllcztcblxuICB2YXIgX3VzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1hcENvbnRleHQpLFxuICAgICAgcGF0aCA9IF91c2VDb250ZXh0LnBhdGg7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHt9KSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgb3V0cHV0ID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldE91dHB1dCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGlmICghZ2VvZ3JhcGh5KSByZXR1cm47XG5cbiAgICBpZiAoaXNTdHJpbmcoZ2VvZ3JhcGh5KSkge1xuICAgICAgZmV0Y2hHZW9ncmFwaGllcyhnZW9ncmFwaHkpLnRoZW4oZnVuY3Rpb24gKGdlb3MpIHtcbiAgICAgICAgaWYgKGdlb3MpIHtcbiAgICAgICAgICBzZXRPdXRwdXQoe1xuICAgICAgICAgICAgZ2VvZ3JhcGhpZXM6IGdldEZlYXR1cmVzKGdlb3MsIHBhcnNlR2VvZ3JhcGhpZXMpLFxuICAgICAgICAgICAgbWVzaDogZ2V0TWVzaChnZW9zKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0T3V0cHV0KHtcbiAgICAgICAgZ2VvZ3JhcGhpZXM6IGdldEZlYXR1cmVzKGdlb2dyYXBoeSwgcGFyc2VHZW9ncmFwaGllcyksXG4gICAgICAgIG1lc2g6IGdldE1lc2goZ2VvZ3JhcGh5KVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZ2VvZ3JhcGh5LCBwYXJzZUdlb2dyYXBoaWVzXSk7XG5cbiAgdmFyIF91c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lc2ggPSBvdXRwdXQubWVzaCB8fCB7fTtcbiAgICB2YXIgcHJlcGFyZWRNZXNoID0gcHJlcGFyZU1lc2gobWVzaC5vdXRsaW5lLCBtZXNoLmJvcmRlcnMsIHBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBnZW9ncmFwaGllczogcHJlcGFyZUZlYXR1cmVzKG91dHB1dC5nZW9ncmFwaGllcywgcGF0aCksXG4gICAgICBvdXRsaW5lOiBwcmVwYXJlZE1lc2gub3V0bGluZSxcbiAgICAgIGJvcmRlcnM6IHByZXBhcmVkTWVzaC5ib3JkZXJzXG4gICAgfTtcbiAgfSwgW291dHB1dCwgcGF0aF0pLFxuICAgICAgZ2VvZ3JhcGhpZXMgPSBfdXNlTWVtby5nZW9ncmFwaGllcyxcbiAgICAgIG91dGxpbmUgPSBfdXNlTWVtby5vdXRsaW5lLFxuICAgICAgYm9yZGVycyA9IF91c2VNZW1vLmJvcmRlcnM7XG5cbiAgcmV0dXJuIHtcbiAgICBnZW9ncmFwaGllczogZ2VvZ3JhcGhpZXMsXG4gICAgb3V0bGluZTogb3V0bGluZSxcbiAgICBib3JkZXJzOiBib3JkZXJzXG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQkOCA9IFtcImdlb2dyYXBoeVwiLCBcImNoaWxkcmVuXCIsIFwicGFyc2VHZW9ncmFwaGllc1wiLCBcImNsYXNzTmFtZVwiXTtcbnZhciBHZW9ncmFwaGllcyA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgZ2VvZ3JhcGh5ID0gX3JlZi5nZW9ncmFwaHksXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBwYXJzZUdlb2dyYXBoaWVzID0gX3JlZi5wYXJzZUdlb2dyYXBoaWVzLFxuICAgICAgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDgpO1xuXG4gIHZhciBfdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCksXG4gICAgICBwYXRoID0gX3VzZUNvbnRleHQucGF0aCxcbiAgICAgIHByb2plY3Rpb24gPSBfdXNlQ29udGV4dC5wcm9qZWN0aW9uO1xuXG4gIHZhciBfdXNlR2VvZ3JhcGhpZXMgPSB1c2VHZW9ncmFwaGllcyh7XG4gICAgZ2VvZ3JhcGh5OiBnZW9ncmFwaHksXG4gICAgcGFyc2VHZW9ncmFwaGllczogcGFyc2VHZW9ncmFwaGllc1xuICB9KSxcbiAgICAgIGdlb2dyYXBoaWVzID0gX3VzZUdlb2dyYXBoaWVzLmdlb2dyYXBoaWVzLFxuICAgICAgb3V0bGluZSA9IF91c2VHZW9ncmFwaGllcy5vdXRsaW5lLFxuICAgICAgYm9yZGVycyA9IF91c2VHZW9ncmFwaGllcy5ib3JkZXJzO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6IFwicnNtLWdlb2dyYXBoaWVzIFwiLmNvbmNhdChjbGFzc05hbWUpXG4gIH0sIHJlc3RQcm9wcyksIGdlb2dyYXBoaWVzICYmIGdlb2dyYXBoaWVzLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW4oe1xuICAgIGdlb2dyYXBoaWVzOiBnZW9ncmFwaGllcyxcbiAgICBvdXRsaW5lOiBvdXRsaW5lLFxuICAgIGJvcmRlcnM6IGJvcmRlcnMsXG4gICAgcGF0aDogcGF0aCxcbiAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uXG4gIH0pKTtcbn0pO1xuR2VvZ3JhcGhpZXMuZGlzcGxheU5hbWUgPSBcIkdlb2dyYXBoaWVzXCI7XG5HZW9ncmFwaGllcy5wcm9wVHlwZXMgPSB7XG4gIGdlb2dyYXBoeTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheV0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBwYXJzZUdlb2dyYXBoaWVzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG5cbnZhciBfZXhjbHVkZWQkNyA9IFtcImdlb2dyYXBoeVwiLCBcIm9uTW91c2VFbnRlclwiLCBcIm9uTW91c2VMZWF2ZVwiLCBcIm9uTW91c2VEb3duXCIsIFwib25Nb3VzZVVwXCIsIFwib25Gb2N1c1wiLCBcIm9uQmx1clwiLCBcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCJdO1xudmFyIEdlb2dyYXBoeSA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgZ2VvZ3JhcGh5ID0gX3JlZi5nZW9ncmFwaHksXG4gICAgICBvbk1vdXNlRW50ZXIgPSBfcmVmLm9uTW91c2VFbnRlcixcbiAgICAgIG9uTW91c2VMZWF2ZSA9IF9yZWYub25Nb3VzZUxlYXZlLFxuICAgICAgb25Nb3VzZURvd24gPSBfcmVmLm9uTW91c2VEb3duLFxuICAgICAgb25Nb3VzZVVwID0gX3JlZi5vbk1vdXNlVXAsXG4gICAgICBvbkZvY3VzID0gX3JlZi5vbkZvY3VzLFxuICAgICAgb25CbHVyID0gX3JlZi5vbkJsdXIsXG4gICAgICBfcmVmJHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3JlZiRzdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHN0eWxlLFxuICAgICAgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDcpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGlzUHJlc3NlZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQcmVzc2VkID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIGlzRm9jdXNlZCA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRGb2N1cyA9IF91c2VTdGF0ZTRbMV07XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihldnQpIHtcbiAgICBzZXRGb2N1cyh0cnVlKTtcbiAgICBpZiAob25Nb3VzZUVudGVyKSBvbk1vdXNlRW50ZXIoZXZ0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZXZ0KSB7XG4gICAgc2V0Rm9jdXMoZmFsc2UpO1xuICAgIGlmIChpc1ByZXNzZWQpIHNldFByZXNzZWQoZmFsc2UpO1xuICAgIGlmIChvbk1vdXNlTGVhdmUpIG9uTW91c2VMZWF2ZShldnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZ0KSB7XG4gICAgc2V0Rm9jdXModHJ1ZSk7XG4gICAgaWYgKG9uRm9jdXMpIG9uRm9jdXMoZXZ0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZ0KSB7XG4gICAgc2V0Rm9jdXMoZmFsc2UpO1xuICAgIGlmIChpc1ByZXNzZWQpIHNldFByZXNzZWQoZmFsc2UpO1xuICAgIGlmIChvbkJsdXIpIG9uQmx1cihldnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2dCkge1xuICAgIHNldFByZXNzZWQodHJ1ZSk7XG4gICAgaWYgKG9uTW91c2VEb3duKSBvbk1vdXNlRG93bihldnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldnQpIHtcbiAgICBzZXRQcmVzc2VkKGZhbHNlKTtcbiAgICBpZiAob25Nb3VzZVVwKSBvbk1vdXNlVXAoZXZ0KTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogXCIwXCIsXG4gICAgY2xhc3NOYW1lOiBcInJzbS1nZW9ncmFwaHkgXCIuY29uY2F0KGNsYXNzTmFtZSksXG4gICAgZDogZ2VvZ3JhcGh5LnN2Z1BhdGgsXG4gICAgb25Nb3VzZUVudGVyOiBoYW5kbGVNb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZSxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICBvbk1vdXNlVXA6IGhhbmRsZU1vdXNlVXAsXG4gICAgc3R5bGU6IHN0eWxlW2lzUHJlc3NlZCB8fCBpc0ZvY3VzZWQgPyBpc1ByZXNzZWQgPyBcInByZXNzZWRcIiA6IFwiaG92ZXJcIiA6IFwiZGVmYXVsdFwiXVxuICB9LCByZXN0UHJvcHMpKTtcbn0pO1xuR2VvZ3JhcGh5LmRpc3BsYXlOYW1lID0gXCJHZW9ncmFwaHlcIjtcbkdlb2dyYXBoeS5wcm9wVHlwZXMgPSB7XG4gIGdlb2dyYXBoeTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25Nb3VzZURvd246IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25Nb3VzZVVwOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIG9uRm9jdXM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25CbHVyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIHN0eWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xufTtcbnZhciBHZW9ncmFwaHkkMSA9IFJlYWN0Lm1lbW8oR2VvZ3JhcGh5KTtcblxudmFyIF9leGNsdWRlZCQ2ID0gW1wiZmlsbFwiLCBcInN0cm9rZVwiLCBcInN0ZXBcIiwgXCJjbGFzc05hbWVcIl07XG52YXIgR3JhdGljdWxlID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XG4gIHZhciBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB2b2lkIDAgPyBcInRyYW5zcGFyZW50XCIgOiBfcmVmJGZpbGwsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHZvaWQgMCA/IFwiY3VycmVudGNvbG9yXCIgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3RlcCA9IF9yZWYuc3RlcCxcbiAgICAgIHN0ZXAgPSBfcmVmJHN0ZXAgPT09IHZvaWQgMCA/IFsxMCwgMTBdIDogX3JlZiRzdGVwLFxuICAgICAgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDYpO1xuXG4gIHZhciBfdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCksXG4gICAgICBwYXRoID0gX3VzZUNvbnRleHQucGF0aDtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgZDogcGF0aChkM0dlby5nZW9HcmF0aWN1bGUoKS5zdGVwKHN0ZXApKCkpLFxuICAgIGZpbGw6IGZpbGwsXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgY2xhc3NOYW1lOiBcInJzbS1ncmF0aWN1bGUgXCIuY29uY2F0KGNsYXNzTmFtZSlcbiAgfSwgcmVzdFByb3BzKSk7XG59KTtcbkdyYXRpY3VsZS5kaXNwbGF5TmFtZSA9IFwiR3JhdGljdWxlXCI7XG5HcmF0aWN1bGUucHJvcFR5cGVzID0ge1xuICBmaWxsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgc3Ryb2tlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgc3RlcDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xufTtcbnZhciBHcmF0aWN1bGUkMSA9IFJlYWN0Lm1lbW8oR3JhdGljdWxlKTtcblxudmFyIF9leGNsdWRlZCQ1ID0gW1widmFsdWVcIl07XG52YXIgWm9vbVBhbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG52YXIgZGVmYXVsdFZhbHVlID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBrOiAxLFxuICB0cmFuc2Zvcm1TdHJpbmc6IFwidHJhbnNsYXRlKDAgMCkgc2NhbGUoMSlcIlxufTtcblxudmFyIFpvb21QYW5Qcm92aWRlciA9IGZ1bmN0aW9uIFpvb21QYW5Qcm92aWRlcihfcmVmKSB7XG4gIHZhciBfcmVmJHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIHZhbHVlID0gX3JlZiR2YWx1ZSA9PT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogX3JlZiR2YWx1ZSxcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkNSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChab29tUGFuQ29udGV4dC5Qcm92aWRlciwgX2V4dGVuZHMoe1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCByZXN0UHJvcHMpKTtcbn07XG5cblpvb21QYW5Qcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICB5OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsXG4gIHRyYW5zZm9ybVN0cmluZzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG5cbnZhciB1c2Vab29tUGFuQ29udGV4dCA9IGZ1bmN0aW9uIHVzZVpvb21QYW5Db250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChab29tUGFuQ29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiB1c2Vab29tUGFuKF9yZWYpIHtcbiAgdmFyIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgZmlsdGVyWm9vbUV2ZW50ID0gX3JlZi5maWx0ZXJab29tRXZlbnQsXG4gICAgICBvbk1vdmVTdGFydCA9IF9yZWYub25Nb3ZlU3RhcnQsXG4gICAgICBvbk1vdmVFbmQgPSBfcmVmLm9uTW92ZUVuZCxcbiAgICAgIG9uTW92ZSA9IF9yZWYub25Nb3ZlLFxuICAgICAgX3JlZiR0cmFuc2xhdGVFeHRlbnQgPSBfcmVmLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IF9yZWYkdHJhbnNsYXRlRXh0ZW50ID09PSB2b2lkIDAgPyBbWy1JbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCBJbmZpbml0eV1dIDogX3JlZiR0cmFuc2xhdGVFeHRlbnQsXG4gICAgICBfcmVmJHNjYWxlRXh0ZW50ID0gX3JlZi5zY2FsZUV4dGVudCxcbiAgICAgIHNjYWxlRXh0ZW50ID0gX3JlZiRzY2FsZUV4dGVudCA9PT0gdm9pZCAwID8gWzEsIDhdIDogX3JlZiRzY2FsZUV4dGVudCxcbiAgICAgIF9yZWYkem9vbSA9IF9yZWYuem9vbSxcbiAgICAgIHpvb20gPSBfcmVmJHpvb20gPT09IHZvaWQgMCA/IDEgOiBfcmVmJHpvb207XG5cbiAgdmFyIF91c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KSxcbiAgICAgIHdpZHRoID0gX3VzZUNvbnRleHQud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfdXNlQ29udGV4dC5oZWlnaHQsXG4gICAgICBwcm9qZWN0aW9uID0gX3VzZUNvbnRleHQucHJvamVjdGlvbjtcblxuICB2YXIgX2NlbnRlciA9IF9zbGljZWRUb0FycmF5KGNlbnRlciwgMiksXG4gICAgICBsb24gPSBfY2VudGVyWzBdLFxuICAgICAgbGF0ID0gX2NlbnRlclsxXTtcblxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBrOiAxXG4gIH0pLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBwb3NpdGlvbiA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQb3NpdGlvbiA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIGxhc3RQb3NpdGlvbiA9IFJlYWN0LnVzZVJlZih7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGs6IDFcbiAgfSk7XG4gIHZhciBtYXBSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHpvb21SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIGJ5cGFzc0V2ZW50cyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG5cbiAgdmFyIF90cmFuc2xhdGVFeHRlbnQgPSBfc2xpY2VkVG9BcnJheSh0cmFuc2xhdGVFeHRlbnQsIDIpLFxuICAgICAgYSA9IF90cmFuc2xhdGVFeHRlbnRbMF0sXG4gICAgICBiID0gX3RyYW5zbGF0ZUV4dGVudFsxXTtcblxuICB2YXIgX2EgPSBfc2xpY2VkVG9BcnJheShhLCAyKSxcbiAgICAgIGExID0gX2FbMF0sXG4gICAgICBhMiA9IF9hWzFdO1xuXG4gIHZhciBfYiA9IF9zbGljZWRUb0FycmF5KGIsIDIpLFxuICAgICAgYjEgPSBfYlswXSxcbiAgICAgIGIyID0gX2JbMV07XG5cbiAgdmFyIF9zY2FsZUV4dGVudCA9IF9zbGljZWRUb0FycmF5KHNjYWxlRXh0ZW50LCAyKSxcbiAgICAgIG1pblpvb20gPSBfc2NhbGVFeHRlbnRbMF0sXG4gICAgICBtYXhab29tID0gX3NjYWxlRXh0ZW50WzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN2ZyA9IGQzU2VsZWN0aW9uLnNlbGVjdChtYXBSZWYuY3VycmVudCk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVab29tU3RhcnQoZDNFdmVudCkge1xuICAgICAgaWYgKCFvbk1vdmVTdGFydCB8fCBieXBhc3NFdmVudHMuY3VycmVudCkgcmV0dXJuO1xuICAgICAgb25Nb3ZlU3RhcnQoe1xuICAgICAgICBjb29yZGluYXRlczogcHJvamVjdGlvbi5pbnZlcnQoZ2V0Q29vcmRzKHdpZHRoLCBoZWlnaHQsIGQzRXZlbnQudHJhbnNmb3JtKSksXG4gICAgICAgIHpvb206IGQzRXZlbnQudHJhbnNmb3JtLmtcbiAgICAgIH0sIGQzRXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVpvb20oZDNFdmVudCkge1xuICAgICAgaWYgKGJ5cGFzc0V2ZW50cy5jdXJyZW50KSByZXR1cm47XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZDNFdmVudC50cmFuc2Zvcm0sXG4gICAgICAgICAgc291cmNlRXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50O1xuICAgICAgc2V0UG9zaXRpb24oe1xuICAgICAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICAgICAgeTogdHJhbnNmb3JtLnksXG4gICAgICAgIGs6IHRyYW5zZm9ybS5rLFxuICAgICAgICBkcmFnZ2luZzogc291cmNlRXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFvbk1vdmUpIHJldHVybjtcbiAgICAgIG9uTW92ZSh7XG4gICAgICAgIHg6IHRyYW5zZm9ybS54LFxuICAgICAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtLmssXG4gICAgICAgIGRyYWdnaW5nOiBzb3VyY2VFdmVudFxuICAgICAgfSwgZDNFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlWm9vbUVuZChkM0V2ZW50KSB7XG4gICAgICBpZiAoYnlwYXNzRXZlbnRzLmN1cnJlbnQpIHtcbiAgICAgICAgYnlwYXNzRXZlbnRzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb2plY3Rpb24kaW52ZXJ0ID0gcHJvamVjdGlvbi5pbnZlcnQoZ2V0Q29vcmRzKHdpZHRoLCBoZWlnaHQsIGQzRXZlbnQudHJhbnNmb3JtKSksXG4gICAgICAgICAgX3Byb2plY3Rpb24kaW52ZXJ0MiA9IF9zbGljZWRUb0FycmF5KF9wcm9qZWN0aW9uJGludmVydCwgMiksXG4gICAgICAgICAgeCA9IF9wcm9qZWN0aW9uJGludmVydDJbMF0sXG4gICAgICAgICAgeSA9IF9wcm9qZWN0aW9uJGludmVydDJbMV07XG5cbiAgICAgIGxhc3RQb3NpdGlvbi5jdXJyZW50ID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBrOiBkM0V2ZW50LnRyYW5zZm9ybS5rXG4gICAgICB9O1xuICAgICAgaWYgKCFvbk1vdmVFbmQpIHJldHVybjtcbiAgICAgIG9uTW92ZUVuZCh7XG4gICAgICAgIGNvb3JkaW5hdGVzOiBbeCwgeV0sXG4gICAgICAgIHpvb206IGQzRXZlbnQudHJhbnNmb3JtLmtcbiAgICAgIH0sIGQzRXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckZ1bmMoZDNFdmVudCkge1xuICAgICAgaWYgKGZpbHRlclpvb21FdmVudCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyWm9vbUV2ZW50KGQzRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZDNFdmVudCA/ICFkM0V2ZW50LmN0cmxLZXkgJiYgIWQzRXZlbnQuYnV0dG9uIDogZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHpvb20gPSBkM1pvb20uem9vbSgpLmZpbHRlcihmaWx0ZXJGdW5jKS5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pLnRyYW5zbGF0ZUV4dGVudChbW2ExLCBhMl0sIFtiMSwgYjJdXSkub24oXCJzdGFydFwiLCBoYW5kbGVab29tU3RhcnQpLm9uKFwiem9vbVwiLCBoYW5kbGVab29tKS5vbihcImVuZFwiLCBoYW5kbGVab29tRW5kKTtcbiAgICB6b29tUmVmLmN1cnJlbnQgPSB6b29tO1xuICAgIHN2Zy5jYWxsKHpvb20pO1xuICB9LCBbd2lkdGgsIGhlaWdodCwgYTEsIGEyLCBiMSwgYjIsIG1pblpvb20sIG1heFpvb20sIHByb2plY3Rpb24sIG9uTW92ZVN0YXJ0LCBvbk1vdmUsIG9uTW92ZUVuZCwgZmlsdGVyWm9vbUV2ZW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGxvbiA9PT0gbGFzdFBvc2l0aW9uLmN1cnJlbnQueCAmJiBsYXQgPT09IGxhc3RQb3NpdGlvbi5jdXJyZW50LnkgJiYgem9vbSA9PT0gbGFzdFBvc2l0aW9uLmN1cnJlbnQuaykgcmV0dXJuO1xuICAgIHZhciBjb29yZHMgPSBwcm9qZWN0aW9uKFtsb24sIGxhdF0pO1xuICAgIHZhciB4ID0gY29vcmRzWzBdICogem9vbTtcbiAgICB2YXIgeSA9IGNvb3Jkc1sxXSAqIHpvb207XG4gICAgdmFyIHN2ZyA9IGQzU2VsZWN0aW9uLnNlbGVjdChtYXBSZWYuY3VycmVudCk7XG4gICAgYnlwYXNzRXZlbnRzLmN1cnJlbnQgPSB0cnVlO1xuICAgIHN2Zy5jYWxsKHpvb21SZWYuY3VycmVudC50cmFuc2Zvcm0sIGQzWm9vbS56b29tSWRlbnRpdHkudHJhbnNsYXRlKHdpZHRoIC8gMiAtIHgsIGhlaWdodCAvIDIgLSB5KS5zY2FsZSh6b29tKSk7XG4gICAgc2V0UG9zaXRpb24oe1xuICAgICAgeDogd2lkdGggLyAyIC0geCxcbiAgICAgIHk6IGhlaWdodCAvIDIgLSB5LFxuICAgICAgazogem9vbVxuICAgIH0pO1xuICAgIGxhc3RQb3NpdGlvbi5jdXJyZW50ID0ge1xuICAgICAgeDogbG9uLFxuICAgICAgeTogbGF0LFxuICAgICAgazogem9vbVxuICAgIH07XG4gIH0sIFtsb24sIGxhdCwgem9vbSwgd2lkdGgsIGhlaWdodCwgcHJvamVjdGlvbl0pO1xuICByZXR1cm4ge1xuICAgIG1hcFJlZjogbWFwUmVmLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICB0cmFuc2Zvcm1TdHJpbmc6IFwidHJhbnNsYXRlKFwiLmNvbmNhdChwb3NpdGlvbi54LCBcIiBcIikuY29uY2F0KHBvc2l0aW9uLnksIFwiKSBzY2FsZShcIikuY29uY2F0KHBvc2l0aW9uLmssIFwiKVwiKVxuICB9O1xufVxuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJjZW50ZXJcIiwgXCJ6b29tXCIsIFwibWluWm9vbVwiLCBcIm1heFpvb21cIiwgXCJ0cmFuc2xhdGVFeHRlbnRcIiwgXCJmaWx0ZXJab29tRXZlbnRcIiwgXCJvbk1vdmVTdGFydFwiLCBcIm9uTW92ZVwiLCBcIm9uTW92ZUVuZFwiLCBcImNsYXNzTmFtZVwiXTtcbnZhciBab29tYWJsZUdyb3VwID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XG4gIHZhciBfcmVmJGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZiRjZW50ZXIgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9yZWYkY2VudGVyLFxuICAgICAgX3JlZiR6b29tID0gX3JlZi56b29tLFxuICAgICAgem9vbSA9IF9yZWYkem9vbSA9PT0gdm9pZCAwID8gMSA6IF9yZWYkem9vbSxcbiAgICAgIF9yZWYkbWluWm9vbSA9IF9yZWYubWluWm9vbSxcbiAgICAgIG1pblpvb20gPSBfcmVmJG1pblpvb20gPT09IHZvaWQgMCA/IDEgOiBfcmVmJG1pblpvb20sXG4gICAgICBfcmVmJG1heFpvb20gPSBfcmVmLm1heFpvb20sXG4gICAgICBtYXhab29tID0gX3JlZiRtYXhab29tID09PSB2b2lkIDAgPyA4IDogX3JlZiRtYXhab29tLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gX3JlZi50cmFuc2xhdGVFeHRlbnQsXG4gICAgICBmaWx0ZXJab29tRXZlbnQgPSBfcmVmLmZpbHRlclpvb21FdmVudCxcbiAgICAgIG9uTW92ZVN0YXJ0ID0gX3JlZi5vbk1vdmVTdGFydCxcbiAgICAgIG9uTW92ZSA9IF9yZWYub25Nb3ZlLFxuICAgICAgb25Nb3ZlRW5kID0gX3JlZi5vbk1vdmVFbmQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkNCk7XG5cbiAgdmFyIF91c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KSxcbiAgICAgIHdpZHRoID0gX3VzZUNvbnRleHQud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfdXNlQ29udGV4dC5oZWlnaHQ7XG5cbiAgdmFyIF91c2Vab29tUGFuID0gdXNlWm9vbVBhbih7XG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgZmlsdGVyWm9vbUV2ZW50OiBmaWx0ZXJab29tRXZlbnQsXG4gICAgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LFxuICAgIG9uTW92ZTogb25Nb3ZlLFxuICAgIG9uTW92ZUVuZDogb25Nb3ZlRW5kLFxuICAgIHNjYWxlRXh0ZW50OiBbbWluWm9vbSwgbWF4Wm9vbV0sXG4gICAgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsXG4gICAgem9vbTogem9vbVxuICB9KSxcbiAgICAgIG1hcFJlZiA9IF91c2Vab29tUGFuLm1hcFJlZixcbiAgICAgIHRyYW5zZm9ybVN0cmluZyA9IF91c2Vab29tUGFuLnRyYW5zZm9ybVN0cmluZyxcbiAgICAgIHBvc2l0aW9uID0gX3VzZVpvb21QYW4ucG9zaXRpb247XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChab29tUGFuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICBrOiBwb3NpdGlvbi5rLFxuICAgICAgdHJhbnNmb3JtU3RyaW5nOiB0cmFuc2Zvcm1TdHJpbmdcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIHJlZjogbWFwUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBmaWxsOiBcInRyYW5zcGFyZW50XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtU3RyaW5nLFxuICAgIGNsYXNzTmFtZTogXCJyc20tem9vbWFibGUtZ3JvdXAgXCIuY29uY2F0KGNsYXNzTmFtZSlcbiAgfSwgcmVzdFByb3BzKSkpKTtcbn0pO1xuWm9vbWFibGVHcm91cC5kaXNwbGF5TmFtZSA9IFwiWm9vbWFibGVHcm91cFwiO1xuWm9vbWFibGVHcm91cC5wcm9wVHlwZXMgPSB7XG4gIGNlbnRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcbiAgem9vbTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsXG4gIG1pblpvb206IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBtYXhab29tOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgdHJhbnNsYXRlRXh0ZW50OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5T2YoUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSksXG4gIG9uTW92ZVN0YXJ0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIG9uTW92ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbk1vdmVFbmQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiaWRcIiwgXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3Ryb2tlV2lkdGhcIiwgXCJjbGFzc05hbWVcIl07XG52YXIgU3BoZXJlID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XG4gIHZhciBfcmVmJGlkID0gX3JlZi5pZCxcbiAgICAgIGlkID0gX3JlZiRpZCA9PT0gdm9pZCAwID8gXCJyc20tc3BoZXJlXCIgOiBfcmVmJGlkLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gXCJ0cmFuc3BhcmVudFwiIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB2b2lkIDAgPyBcImN1cnJlbnRjb2xvclwiIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQzKTtcblxuICB2YXIgX3VzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1hcENvbnRleHQpLFxuICAgICAgcGF0aCA9IF91c2VDb250ZXh0LnBhdGg7XG5cbiAgdmFyIHNwaGVyZVBhdGggPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGF0aCh7XG4gICAgICB0eXBlOiBcIlNwaGVyZVwiXG4gICAgfSk7XG4gIH0sIFtwYXRoXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgIGlkOiBpZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBzcGhlcmVQYXRoXG4gIH0pKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIGQ6IHNwaGVyZVBhdGgsXG4gICAgZmlsbDogZmlsbCxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwicnNtLXNwaGVyZSBcIi5jb25jYXQoY2xhc3NOYW1lKVxuICB9LCByZXN0UHJvcHMpKSk7XG59KTtcblNwaGVyZS5kaXNwbGF5TmFtZSA9IFwiU3BoZXJlXCI7XG5TcGhlcmUucHJvcFR5cGVzID0ge1xuICBpZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGZpbGw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBzdHJva2U6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG52YXIgU3BoZXJlJDEgPSBSZWFjdC5tZW1vKFNwaGVyZSk7XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImNvb3JkaW5hdGVzXCIsIFwiY2hpbGRyZW5cIiwgXCJvbk1vdXNlRW50ZXJcIiwgXCJvbk1vdXNlTGVhdmVcIiwgXCJvbk1vdXNlRG93blwiLCBcIm9uTW91c2VVcFwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiXTtcbnZhciBNYXJrZXIgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmLCByZWYpIHtcbiAgdmFyIGNvb3JkaW5hdGVzID0gX3JlZi5jb29yZGluYXRlcyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIG9uTW91c2VFbnRlciA9IF9yZWYub25Nb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlID0gX3JlZi5vbk1vdXNlTGVhdmUsXG4gICAgICBvbk1vdXNlRG93biA9IF9yZWYub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXAgPSBfcmVmLm9uTW91c2VVcCxcbiAgICAgIG9uRm9jdXMgPSBfcmVmLm9uRm9jdXMsXG4gICAgICBvbkJsdXIgPSBfcmVmLm9uQmx1cixcbiAgICAgIF9yZWYkc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgc3R5bGUgPSBfcmVmJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkc3R5bGUsXG4gICAgICBfcmVmJGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZiRjbGFzc05hbWUgPT09IHZvaWQgMCA/IFwiXCIgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkMik7XG5cbiAgdmFyIF91c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KSxcbiAgICAgIHByb2plY3Rpb24gPSBfdXNlQ29udGV4dC5wcm9qZWN0aW9uO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGlzUHJlc3NlZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQcmVzc2VkID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIGlzRm9jdXNlZCA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRGb2N1cyA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdmFyIF9wcm9qZWN0aW9uID0gcHJvamVjdGlvbihjb29yZGluYXRlcyksXG4gICAgICBfcHJvamVjdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfcHJvamVjdGlvbiwgMiksXG4gICAgICB4ID0gX3Byb2plY3Rpb24yWzBdLFxuICAgICAgeSA9IF9wcm9qZWN0aW9uMlsxXTtcblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKGV2dCkge1xuICAgIHNldEZvY3VzKHRydWUpO1xuICAgIGlmIChvbk1vdXNlRW50ZXIpIG9uTW91c2VFbnRlcihldnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShldnQpIHtcbiAgICBzZXRGb2N1cyhmYWxzZSk7XG4gICAgaWYgKGlzUHJlc3NlZCkgc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgaWYgKG9uTW91c2VMZWF2ZSkgb25Nb3VzZUxlYXZlKGV2dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldnQpIHtcbiAgICBzZXRGb2N1cyh0cnVlKTtcbiAgICBpZiAob25Gb2N1cykgb25Gb2N1cyhldnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmx1cihldnQpIHtcbiAgICBzZXRGb2N1cyhmYWxzZSk7XG4gICAgaWYgKGlzUHJlc3NlZCkgc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgaWYgKG9uQmx1cikgb25CbHVyKGV2dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZ0KSB7XG4gICAgc2V0UHJlc3NlZCh0cnVlKTtcbiAgICBpZiAob25Nb3VzZURvd24pIG9uTW91c2VEb3duKGV2dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2dCkge1xuICAgIHNldFByZXNzZWQoZmFsc2UpO1xuICAgIGlmIChvbk1vdXNlVXApIG9uTW91c2VVcChldnQpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwiLCBcIikuY29uY2F0KHksIFwiKVwiKSxcbiAgICBjbGFzc05hbWU6IFwicnNtLW1hcmtlciBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICBvbk1vdXNlRW50ZXI6IGhhbmRsZU1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVNb3VzZUxlYXZlLFxuICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbk1vdXNlRG93bjogaGFuZGxlTW91c2VEb3duLFxuICAgIG9uTW91c2VVcDogaGFuZGxlTW91c2VVcCxcbiAgICBzdHlsZTogc3R5bGVbaXNQcmVzc2VkIHx8IGlzRm9jdXNlZCA/IGlzUHJlc3NlZCA/IFwicHJlc3NlZFwiIDogXCJob3ZlclwiIDogXCJkZWZhdWx0XCJdXG4gIH0sIHJlc3RQcm9wcyksIGNoaWxkcmVuKTtcbn0pO1xuTWFya2VyLmRpc3BsYXlOYW1lID0gXCJNYXJrZXJcIjtcbk1hcmtlci5wcm9wVHlwZXMgPSB7XG4gIGNvb3JkaW5hdGVzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5LFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheU9mKFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSldKSxcbiAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbk1vdXNlRG93bjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbk1vdXNlVXA6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25Gb2N1czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbkJsdXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgc3R5bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJmcm9tXCIsIFwidG9cIiwgXCJjb29yZGluYXRlc1wiLCBcInN0cm9rZVwiLCBcInN0cm9rZVdpZHRoXCIsIFwiZmlsbFwiLCBcImNsYXNzTmFtZVwiXTtcbnZhciBMaW5lID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XG4gIHZhciBfcmVmJGZyb20gPSBfcmVmLmZyb20sXG4gICAgICBmcm9tID0gX3JlZiRmcm9tID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfcmVmJGZyb20sXG4gICAgICBfcmVmJHRvID0gX3JlZi50byxcbiAgICAgIHRvID0gX3JlZiR0byA9PT0gdm9pZCAwID8gWzAsIDBdIDogX3JlZiR0byxcbiAgICAgIGNvb3JkaW5hdGVzID0gX3JlZi5jb29yZGluYXRlcyxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdm9pZCAwID8gXCJjdXJyZW50Y29sb3JcIiA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHZvaWQgMCA/IDMgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gXCJ0cmFuc3BhcmVudFwiIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuXG4gIHZhciBfdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCksXG4gICAgICBwYXRoID0gX3VzZUNvbnRleHQucGF0aDtcblxuICB2YXIgbGluZURhdGEgPSB7XG4gICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIHx8IFtmcm9tLCB0b11cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIGQ6IHBhdGgobGluZURhdGEpLFxuICAgIGNsYXNzTmFtZTogXCJyc20tbGluZSBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgZmlsbDogZmlsbFxuICB9LCByZXN0UHJvcHMpKTtcbn0pO1xuTGluZS5kaXNwbGF5TmFtZSA9IFwiTGluZVwiO1xuTGluZS5wcm9wVHlwZXMgPSB7XG4gIGZyb206IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXksXG4gIHRvOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5LFxuICBjb29yZGluYXRlczogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcbiAgc3Ryb2tlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBmaWxsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInN1YmplY3RcIiwgXCJjaGlsZHJlblwiLCBcImNvbm5lY3RvclByb3BzXCIsIFwiZHhcIiwgXCJkeVwiLCBcImN1cnZlXCIsIFwiY2xhc3NOYW1lXCJdO1xudmFyIEFubm90YXRpb24gPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmLCByZWYpIHtcbiAgdmFyIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjb25uZWN0b3JQcm9wcyA9IF9yZWYuY29ubmVjdG9yUHJvcHMsXG4gICAgICBfcmVmJGR4ID0gX3JlZi5keCxcbiAgICAgIGR4ID0gX3JlZiRkeCA9PT0gdm9pZCAwID8gMzAgOiBfcmVmJGR4LFxuICAgICAgX3JlZiRkeSA9IF9yZWYuZHksXG4gICAgICBkeSA9IF9yZWYkZHkgPT09IHZvaWQgMCA/IDMwIDogX3JlZiRkeSxcbiAgICAgIF9yZWYkY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgY3VydmUgPSBfcmVmJGN1cnZlID09PSB2b2lkIDAgPyAwIDogX3JlZiRjdXJ2ZSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgdmFyIF91c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KSxcbiAgICAgIHByb2plY3Rpb24gPSBfdXNlQ29udGV4dC5wcm9qZWN0aW9uO1xuXG4gIHZhciBfcHJvamVjdGlvbiA9IHByb2plY3Rpb24oc3ViamVjdCksXG4gICAgICBfcHJvamVjdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfcHJvamVjdGlvbiwgMiksXG4gICAgICB4ID0gX3Byb2plY3Rpb24yWzBdLFxuICAgICAgeSA9IF9wcm9qZWN0aW9uMlsxXTtcblxuICB2YXIgY29ubmVjdG9yUGF0aCA9IGNyZWF0ZUNvbm5lY3RvclBhdGgoZHgsIGR5LCBjdXJ2ZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4ICsgZHgsIFwiLCBcIikuY29uY2F0KHkgKyBkeSwgXCIpXCIpLFxuICAgIGNsYXNzTmFtZTogXCJyc20tYW5ub3RhdGlvbiBcIi5jb25jYXQoY2xhc3NOYW1lKVxuICB9LCByZXN0UHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHtcbiAgICBkOiBjb25uZWN0b3JQYXRoLFxuICAgIGZpbGw6IFwidHJhbnNwYXJlbnRcIixcbiAgICBzdHJva2U6IFwiIzAwMFwiXG4gIH0sIGNvbm5lY3RvclByb3BzKSksIGNoaWxkcmVuKTtcbn0pO1xuQW5ub3RhdGlvbi5kaXNwbGF5TmFtZSA9IFwiQW5ub3RhdGlvblwiO1xuQW5ub3RhdGlvbi5wcm9wVHlwZXMgPSB7XG4gIHN1YmplY3Q6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5T2YoUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlKV0pLFxuICBkeDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsXG4gIGR5OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgY3VydmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBjb25uZWN0b3JQcm9wczogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG5cbmV4cG9ydHMuQW5ub3RhdGlvbiA9IEFubm90YXRpb247XG5leHBvcnRzLkNvbXBvc2FibGVNYXAgPSBDb21wb3NhYmxlTWFwO1xuZXhwb3J0cy5HZW9ncmFwaGllcyA9IEdlb2dyYXBoaWVzO1xuZXhwb3J0cy5HZW9ncmFwaHkgPSBHZW9ncmFwaHkkMTtcbmV4cG9ydHMuR3JhdGljdWxlID0gR3JhdGljdWxlJDE7XG5leHBvcnRzLkxpbmUgPSBMaW5lO1xuZXhwb3J0cy5NYXBDb250ZXh0ID0gTWFwQ29udGV4dDtcbmV4cG9ydHMuTWFwUHJvdmlkZXIgPSBNYXBQcm92aWRlcjtcbmV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuZXhwb3J0cy5TcGhlcmUgPSBTcGhlcmUkMTtcbmV4cG9ydHMuWm9vbVBhbkNvbnRleHQgPSBab29tUGFuQ29udGV4dDtcbmV4cG9ydHMuWm9vbVBhblByb3ZpZGVyID0gWm9vbVBhblByb3ZpZGVyO1xuZXhwb3J0cy5ab29tYWJsZUdyb3VwID0gWm9vbWFibGVHcm91cDtcbmV4cG9ydHMudXNlR2VvZ3JhcGhpZXMgPSB1c2VHZW9ncmFwaGllcztcbmV4cG9ydHMudXNlTWFwQ29udGV4dCA9IHVzZU1hcENvbnRleHQ7XG5leHBvcnRzLnVzZVpvb21QYW4gPSB1c2Vab29tUGFuO1xuZXhwb3J0cy51c2Vab29tUGFuQ29udGV4dCA9IHVzZVpvb21QYW5Db250ZXh0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVhY3QiLCJyZXF1aXJlIiwiUHJvcFR5cGVzIiwiZDNHZW8iLCJ0b3BvanNvbkNsaWVudCIsImQzWm9vbSIsImQzU2VsZWN0aW9uIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsIlJlYWN0X19kZWZhdWx0IiwiUHJvcFR5cGVzX19kZWZhdWx0IiwiZDNHZW9fX25hbWVzcGFjZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJkb25lIiwiZXJyIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJUeXBlRXJyb3IiLCJfZXhjbHVkZWQkYSIsImdlb1BhdGgiLCJwcm9qZWN0aW9ucyIsIk1hcENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwibWFrZVByb2plY3Rpb24iLCJfcmVmIiwiX3JlZiRwcm9qZWN0aW9uQ29uZmlnIiwicHJvamVjdGlvbkNvbmZpZyIsIl9yZWYkcHJvamVjdGlvbiIsInByb2plY3Rpb24iLCJfcmVmJHdpZHRoIiwid2lkdGgiLCJfcmVmJGhlaWdodCIsImhlaWdodCIsImlzRnVuYyIsInByb2oiLCJ0cmFuc2xhdGUiLCJzdXBwb3J0ZWQiLCJjZW50ZXIiLCJyb3RhdGUiLCJzY2FsZSIsInBhcmFsbGVscyIsIk1hcFByb3ZpZGVyIiwiX3JlZjIiLCJyZXN0UHJvcHMiLCJfcmVmMyIsIl9yZWY0IiwiY3giLCJjeSIsIl9yZWY1IiwiX3JlZjYiLCJyeCIsInJ5IiwicnoiLCJfcmVmNyIsIl9yZWY4IiwicDEiLCJwMiIsInMiLCJwcm9qTWVtbyIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsInBhdGgiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJwcm9wVHlwZXMiLCJudW1iZXIiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJmdW5jIiwidXNlTWFwQ29udGV4dCIsInVzZUNvbnRleHQiLCJfZXhjbHVkZWQkOSIsIkNvbXBvc2FibGVNYXAiLCJmb3J3YXJkUmVmIiwicmVmIiwiX3JlZiRjbGFzc05hbWUiLCJjbGFzc05hbWUiLCJ2aWV3Qm94IiwiY29uY2F0IiwiZGlzcGxheU5hbWUiLCJnZXRDb29yZHMiLCJ3IiwiaCIsInQiLCJ4T2Zmc2V0IiwieU9mZnNldCIsIngiLCJ5IiwiZmV0Y2hHZW9ncmFwaGllcyIsInVybCIsImZldGNoIiwidGhlbiIsInJlcyIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwianNvbiIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImdldEZlYXR1cmVzIiwiZ2VvZ3JhcGhpZXMiLCJwYXJzZUdlb2dyYXBoaWVzIiwiaXNUb3BvanNvbiIsInR5cGUiLCJmZWF0dXJlcyIsImZlYXRzIiwiZmVhdHVyZSIsIm9iamVjdHMiLCJnZXRNZXNoIiwib3V0bGluZSIsIm1lc2giLCJhIiwiYiIsImJvcmRlcnMiLCJwcmVwYXJlTWVzaCIsInJzbUtleSIsInN2Z1BhdGgiLCJwcmVwYXJlRmVhdHVyZXMiLCJtYXAiLCJjcmVhdGVDb25uZWN0b3JQYXRoIiwiZHgiLCJ1bmRlZmluZWQiLCJkeSIsImN1cnZlIiwiY3VydmF0dXJlIiwiY3VydmVYIiwiY3VydmVZIiwiaXNTdHJpbmciLCJnZW8iLCJ1c2VHZW9ncmFwaGllcyIsImdlb2dyYXBoeSIsIl91c2VDb250ZXh0IiwiX3VzZVN0YXRlIiwidXNlU3RhdGUiLCJfdXNlU3RhdGUyIiwib3V0cHV0Iiwic2V0T3V0cHV0IiwidXNlRWZmZWN0Iiwid2luZG93IiwiZ2VvcyIsIl91c2VNZW1vIiwicHJlcGFyZWRNZXNoIiwiX2V4Y2x1ZGVkJDgiLCJHZW9ncmFwaGllcyIsImNoaWxkcmVuIiwiX3VzZUdlb2dyYXBoaWVzIiwiYXJyYXkiLCJfZXhjbHVkZWQkNyIsIkdlb2dyYXBoeSIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIm9uTW91c2VEb3duIiwib25Nb3VzZVVwIiwib25Gb2N1cyIsIm9uQmx1ciIsIl9yZWYkc3R5bGUiLCJzdHlsZSIsImlzUHJlc3NlZCIsInNldFByZXNzZWQiLCJfdXNlU3RhdGUzIiwiX3VzZVN0YXRlNCIsImlzRm9jdXNlZCIsInNldEZvY3VzIiwiaGFuZGxlTW91c2VFbnRlciIsImV2dCIsImhhbmRsZU1vdXNlTGVhdmUiLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwidGFiSW5kZXgiLCJHZW9ncmFwaHkkMSIsIm1lbW8iLCJfZXhjbHVkZWQkNiIsIkdyYXRpY3VsZSIsIl9yZWYkZmlsbCIsImZpbGwiLCJfcmVmJHN0cm9rZSIsInN0cm9rZSIsIl9yZWYkc3RlcCIsInN0ZXAiLCJnZW9HcmF0aWN1bGUiLCJHcmF0aWN1bGUkMSIsIl9leGNsdWRlZCQ1IiwiWm9vbVBhbkNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJ0cmFuc2Zvcm1TdHJpbmciLCJab29tUGFuUHJvdmlkZXIiLCJfcmVmJHZhbHVlIiwidXNlWm9vbVBhbkNvbnRleHQiLCJ1c2Vab29tUGFuIiwiZmlsdGVyWm9vbUV2ZW50Iiwib25Nb3ZlU3RhcnQiLCJvbk1vdmVFbmQiLCJvbk1vdmUiLCJfcmVmJHRyYW5zbGF0ZUV4dGVudCIsInRyYW5zbGF0ZUV4dGVudCIsIkluZmluaXR5IiwiX3JlZiRzY2FsZUV4dGVudCIsInNjYWxlRXh0ZW50IiwiX3JlZiR6b29tIiwiem9vbSIsIl9jZW50ZXIiLCJsb24iLCJsYXQiLCJwb3NpdGlvbiIsInNldFBvc2l0aW9uIiwibGFzdFBvc2l0aW9uIiwidXNlUmVmIiwibWFwUmVmIiwiem9vbVJlZiIsImJ5cGFzc0V2ZW50cyIsIl90cmFuc2xhdGVFeHRlbnQiLCJfYSIsImExIiwiYTIiLCJfYiIsImIxIiwiYjIiLCJfc2NhbGVFeHRlbnQiLCJtaW5ab29tIiwibWF4Wm9vbSIsInN2ZyIsInNlbGVjdCIsImN1cnJlbnQiLCJoYW5kbGVab29tU3RhcnQiLCJkM0V2ZW50IiwiY29vcmRpbmF0ZXMiLCJpbnZlcnQiLCJ0cmFuc2Zvcm0iLCJoYW5kbGVab29tIiwic291cmNlRXZlbnQiLCJkcmFnZ2luZyIsImhhbmRsZVpvb21FbmQiLCJfcHJvamVjdGlvbiRpbnZlcnQiLCJfcHJvamVjdGlvbiRpbnZlcnQyIiwiZmlsdGVyRnVuYyIsImN0cmxLZXkiLCJidXR0b24iLCJvbiIsImNvb3JkcyIsInpvb21JZGVudGl0eSIsIl9leGNsdWRlZCQ0IiwiWm9vbWFibGVHcm91cCIsIl9yZWYkY2VudGVyIiwiX3JlZiRtaW5ab29tIiwiX3JlZiRtYXhab29tIiwiX3VzZVpvb21QYW4iLCJhcnJheU9mIiwiX2V4Y2x1ZGVkJDMiLCJTcGhlcmUiLCJfcmVmJGlkIiwiaWQiLCJfcmVmJHN0cm9rZVdpZHRoIiwic3Ryb2tlV2lkdGgiLCJzcGhlcmVQYXRoIiwiRnJhZ21lbnQiLCJwb2ludGVyRXZlbnRzIiwiU3BoZXJlJDEiLCJfZXhjbHVkZWQkMiIsIk1hcmtlciIsIl9wcm9qZWN0aW9uIiwiX3Byb2plY3Rpb24yIiwibm9kZSIsIl9leGNsdWRlZCQxIiwiTGluZSIsIl9yZWYkZnJvbSIsIl9yZWYkdG8iLCJ0byIsImxpbmVEYXRhIiwiX2V4Y2x1ZGVkIiwiQW5ub3RhdGlvbiIsInN1YmplY3QiLCJjb25uZWN0b3JQcm9wcyIsIl9yZWYkZHgiLCJfcmVmJGR5IiwiX3JlZiRjdXJ2ZSIsImNvbm5lY3RvclBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-simple-maps/dist/index.js\n");

/***/ })

};
;